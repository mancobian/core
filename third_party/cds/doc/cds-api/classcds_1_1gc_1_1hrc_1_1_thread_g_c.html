<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cds: cds::gc::hrc::ThreadGC Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacecds.html">cds</a>      </li>
      <li><a class="el" href="namespacecds_1_1gc.html">gc</a>      </li>
      <li><a class="el" href="namespacecds_1_1gc_1_1hrc.html">hrc</a>      </li>
      <li><a class="el" href="classcds_1_1gc_1_1hrc_1_1_thread_g_c.html">ThreadGC</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>cds::gc::hrc::ThreadGC Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="cds::gc::hrc::ThreadGC" -->
<p>Thread's Garbage collector.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;hrc.h&gt;</code></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3296ae8e5dc34c7cd9434fe147376595"></a><!-- doxytag: member="cds::gc::hrc::ThreadGC::isInitialized" ref="a3296ae8e5dc34c7cd9434fe147376595" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_thread_g_c.html#a3296ae8e5dc34c7cd9434fe147376595">isInitialized</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if thread GC is initialized. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14a8a22722e189e6bcbe3cb54e3ffce0"></a><!-- doxytag: member="cds::gc::hrc::ThreadGC::init" ref="a14a8a22722e189e6bcbe3cb54e3ffce0" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_thread_g_c.html#a14a8a22722e189e6bcbe3cb54e3ffce0">init</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization. Multiple calls is allowed. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2f00475566935f759995d28dd7e0e66"></a><!-- doxytag: member="cds::gc::hrc::ThreadGC::fini" ref="ab2f00475566935f759995d28dd7e0e66" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_thread_g_c.html#ab2f00475566935f759995d28dd7e0e66">fini</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalization. Multiple calls is allowed. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72bb34d94fb65e83ac7d5b904320fa4b"></a><!-- doxytag: member="cds::gc::hrc::ThreadGC::allocGuard" ref="a72bb34d94fb65e83ac7d5b904320fa4b" args="(details::HPGuard &amp;guard)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_thread_g_c.html#a72bb34d94fb65e83ac7d5b904320fa4b">allocGuard</a> (<a class="el" href="classcds_1_1gc_1_1hzp_1_1details_1_1_h_p_guard_t.html">details::HPGuard</a> &amp;guard)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes HP guard <code>guard</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7b59f2eb7b0153bcdae0fe720e7179a"></a><!-- doxytag: member="cds::gc::hrc::ThreadGC::freeGuard" ref="aa7b59f2eb7b0153bcdae0fe720e7179a" args="(details::HPGuard &amp;guard)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_thread_g_c.html#aa7b59f2eb7b0153bcdae0fe720e7179a">freeGuard</a> (<a class="el" href="classcds_1_1gc_1_1hzp_1_1details_1_1_h_p_guard_t.html">details::HPGuard</a> &amp;guard)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees HP guard <code>guard</code>. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a4fd55f1ec0c454ef104da95b860a3ce3"></a><!-- doxytag: member="cds::gc::hrc::ThreadGC::allocGuard" ref="a4fd55f1ec0c454ef104da95b860a3ce3" args="(details::HPArray&lt; COUNT &gt; &amp;arr)" -->
template&lt;size_t COUNT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_thread_g_c.html#a4fd55f1ec0c454ef104da95b860a3ce3">allocGuard</a> (<a class="el" href="classcds_1_1gc_1_1hrc_1_1details_1_1_h_p_array.html">details::HPArray</a>&lt; COUNT &gt; &amp;arr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes HP guard array <code>arr</code>. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a64c53b7df175251051ef5732b0ee09e2"></a><!-- doxytag: member="cds::gc::hrc::ThreadGC::freeGuard" ref="a64c53b7df175251051ef5732b0ee09e2" args="(details::HPArray&lt; COUNT &gt; &amp;arr)" -->
template&lt;size_t COUNT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_thread_g_c.html#a64c53b7df175251051ef5732b0ee09e2">freeGuard</a> (<a class="el" href="classcds_1_1gc_1_1hrc_1_1details_1_1_h_p_array.html">details::HPArray</a>&lt; COUNT &gt; &amp;arr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees HP guard array <code>arr</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a478e42b412704200ec5284d93e240038"></a><!-- doxytag: member="cds::gc::hrc::ThreadGC::retireNode" ref="a478e42b412704200ec5284d93e240038" args="(ContainerNode *pNode, details::HPGuard &amp;hp)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_thread_g_c.html#a478e42b412704200ec5284d93e240038">retireNode</a> (<a class="el" href="classcds_1_1gc_1_1hrc_1_1_container_node.html">ContainerNode</a> *pNode, <a class="el" href="classcds_1_1gc_1_1hzp_1_1details_1_1_h_p_guard_t.html">details::HPGuard</a> &amp;hp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retire (deferred delete) node <code>pNode</code> guarded by <code>hp</code> hazard pointer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f1765a54ef06f39d7108288c2d75c81"></a><!-- doxytag: member="cds::gc::hrc::ThreadGC::retireNode" ref="a1f1765a54ef06f39d7108288c2d75c81" args="(ContainerNode *pNode, ContainerNode *&amp;hp)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_thread_g_c.html#a1f1765a54ef06f39d7108288c2d75c81">retireNode</a> (<a class="el" href="classcds_1_1gc_1_1hrc_1_1_container_node.html">ContainerNode</a> *pNode, <a class="el" href="classcds_1_1gc_1_1hrc_1_1_container_node.html">ContainerNode</a> *&amp;hp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retire (deferred delete) node <code>pNode</code> placed in <code>hp</code> hazard pointer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a575fe916731e8e8a534f04afaec7dff9"></a><!-- doxytag: member="cds::gc::hrc::ThreadGC::retireNode" ref="a575fe916731e8e8a534f04afaec7dff9" args="(ContainerNode *pNode)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_thread_g_c.html#a575fe916731e8e8a534f04afaec7dff9">retireNode</a> (<a class="el" href="classcds_1_1gc_1_1hrc_1_1_container_node.html">ContainerNode</a> *pNode)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retire (deferred delete) node <code>pNode</code>. Do not use this function directly! <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TNODE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static TNODE *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_thread_g_c.html#a01924cfd6cabc3429c2bc34a4ce36591">derefLink</a> (TNODE *volatile *ppNode, <a class="el" href="classcds_1_1gc_1_1hrc_1_1_container_node.html">ContainerNode</a> *&amp;hp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely de-references <code>ppNode</code> link.  <a href="#a01924cfd6cabc3429c2bc34a4ce36591"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TNODE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static TNODE *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_thread_g_c.html#af246c41cc122f2ce50c490a97519c0c6">derefLink</a> (TNODE *volatile *ppNode, <a class="el" href="classcds_1_1gc_1_1hzp_1_1details_1_1_h_p_guard_t.html">details::HPGuard</a> &amp;hp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely de-references <code>ppNode</code> link.  <a href="#af246c41cc122f2ce50c490a97519c0c6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TNODE , int BITS&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static <br class="typebreak"/>
<a class="el" href="classcds_1_1details_1_1marked__ptr.html">cds::details::marked_ptr</a><br class="typebreak"/>
&lt; TNODE, BITS &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_thread_g_c.html#ad2bd844b18bdb3b4e5e942f4363f4257">derefLink</a> (<a class="el" href="classcds_1_1details_1_1marked__ptr.html">cds::details::marked_ptr</a>&lt; TNODE, BITS &gt; *ppNode, <a class="el" href="classcds_1_1gc_1_1hrc_1_1_container_node.html">ContainerNode</a> *&amp;hp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely de-reference <code>ppNode</code> marked_node.  <a href="#ad2bd844b18bdb3b4e5e942f4363f4257"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_thread_g_c.html#a57ac62d7423cdd7eee476c9118969869">releaseRef</a> (<a class="el" href="classcds_1_1gc_1_1hrc_1_1_container_node.html">ContainerNode</a> *&amp;hp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases reference.  <a href="#a57ac62d7423cdd7eee476c9118969869"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TNODE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_thread_g_c.html#ab8433bed216a0c1d80d64f4a8bde86e2">CASRef</a> (TNODE *volatile *ppLink, TNODE *pOld, TNODE *pNew)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates <code>*ppLink</code> node from current value <code>pOld</code> to new value <code>pNew</code>.  <a href="#ab8433bed216a0c1d80d64f4a8bde86e2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TNODE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static TNODE *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_thread_g_c.html#a71285d53056976dc0041960ed69202a2">xchgRef</a> (TNODE *volatile *ppLink, TNODE *pNew)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates <code>*ppLink</code> node from any value to new value <code>pNew</code>. Returns old value of <code>*ppLink</code>.  <a href="#a71285d53056976dc0041960ed69202a2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TNODE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_thread_g_c.html#a47437ba0754704462a2a25a6194bea85">storeRef</a> (TNODE *volatile *ppLink, TNODE *pNew)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates <code>*ppLink</code> to new value <code>pNew</code> when no concurrent updates will be possible.  <a href="#a47437ba0754704462a2a25a6194bea85"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7cf2f13d21815de3f98684d5607be4d1"></a><!-- doxytag: member="cds::gc::hrc::ThreadGC::cleanUpLocal" ref="a7cf2f13d21815de3f98684d5607be4d1" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_thread_g_c.html#a7cf2f13d21815de3f98684d5607be4d1">cleanUpLocal</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The procedure will try to remove redundant claimed references from link in deleted nodes that has been deleted by this thread. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2a1c17d085367ac6c4ef3aeb9f13d34"></a><!-- doxytag: member="cds::gc::hrc::ThreadGC::m_gc" ref="ac2a1c17d085367ac6c4ef3aeb9f13d34" args="" -->
<a class="el" href="classcds_1_1gc_1_1hrc_1_1_garbage_collector.html">GarbageCollector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_thread_g_c.html#ac2a1c17d085367ac6c4ef3aeb9f13d34">m_gc</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">master garbage collector <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72688fb4ec13cd25f7c8521ce39aa541"></a><!-- doxytag: member="cds::gc::hrc::ThreadGC::m_pDesc" ref="a72688fb4ec13cd25f7c8521ce39aa541" args="" -->
<a class="el" href="structcds_1_1gc_1_1hrc_1_1details_1_1thread__descriptor.html">details::thread_descriptor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_thread_g_c.html#a72688fb4ec13cd25f7c8521ce39aa541">m_pDesc</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">descriptor of GC data for the thread <br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed63c75a6d93c19ed9b14ec512386a34"></a><!-- doxytag: member="cds::gc::hrc::ThreadGC::GarbageCollector" ref="aed63c75a6d93c19ed9b14ec512386a34" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><b>GarbageCollector</b></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Thread's Garbage collector. </p>
<p>To use HRC reclamation schema each thread object must be linked with the object of <a class="el" href="classcds_1_1gc_1_1hrc_1_1_thread_g_c.html" title="Thread&#39;s Garbage collector.">ThreadGC</a> class that interacts with <a class="el" href="classcds_1_1gc_1_1hrc_1_1_garbage_collector.html" title="Gidenstam&#39;s Garbage Collector.">GarbageCollector</a> global object. The linkage is performed by calling <a class="el" href="namespacecds_1_1threading.html" title="Threading support.">cds::threading</a> <code>Manager::attachThread()</code> on the start of each thread that uses HRC GC. Before terminating the thread linked to HRC GC it is necessary to call <a class="el" href="namespacecds_1_1threading.html" title="Threading support.">cds::threading</a> <code>Manager::detachThread()</code>. </p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ab8433bed216a0c1d80d64f4a8bde86e2"></a><!-- doxytag: member="cds::gc::hrc::ThreadGC::CASRef" ref="ab8433bed216a0c1d80d64f4a8bde86e2" args="(TNODE *volatile *ppLink, TNODE *pOld, TNODE *pNew)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TNODE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static bool cds::gc::hrc::ThreadGC::CASRef </td>
          <td>(</td>
          <td class="paramtype">TNODE *volatile *&#160;</td>
          <td class="paramname"> <em>ppLink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TNODE *&#160;</td>
          <td class="paramname"> <em>pOld</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TNODE *&#160;</td>
          <td class="paramname"> <em>pNew</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updates <code>*ppLink</code> node from current value <code>pOld</code> to new value <code>pNew</code>. </p>
<p>May be used when concurrent updates is possible</p>
<p><code>TNODE</code> - class derived from <a class="el" href="classcds_1_1gc_1_1hrc_1_1_container_node.html" title="Base class for all HRC-based container&#39;s node.">ContainerNode</a> type </p>

</div>
</div>
<a class="anchor" id="a01924cfd6cabc3429c2bc34a4ce36591"></a><!-- doxytag: member="cds::gc::hrc::ThreadGC::derefLink" ref="a01924cfd6cabc3429c2bc34a4ce36591" args="(TNODE *volatile *ppNode, ContainerNode *&amp;hp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TNODE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static TNODE* cds::gc::hrc::ThreadGC::derefLink </td>
          <td>(</td>
          <td class="paramtype">TNODE *volatile *&#160;</td>
          <td class="paramname"> <em>ppNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_container_node.html">ContainerNode</a> *&amp;&#160;</td>
          <td class="paramname"> <em>hp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Safely de-references <code>ppNode</code> link. </p>
<p>Safely de-references <code>ppNode</code> link and sets <code>hp</code> hazard pointer to the de-referenced node <code>TNODE</code> - class derived from <a class="el" href="classcds_1_1gc_1_1hrc_1_1_container_node.html" title="Base class for all HRC-based container&#39;s node.">ContainerNode</a> type </p>

</div>
</div>
<a class="anchor" id="af246c41cc122f2ce50c490a97519c0c6"></a><!-- doxytag: member="cds::gc::hrc::ThreadGC::derefLink" ref="af246c41cc122f2ce50c490a97519c0c6" args="(TNODE *volatile *ppNode, details::HPGuard &amp;hp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TNODE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static TNODE* cds::gc::hrc::ThreadGC::derefLink </td>
          <td>(</td>
          <td class="paramtype">TNODE *volatile *&#160;</td>
          <td class="paramname"> <em>ppNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcds_1_1gc_1_1hzp_1_1details_1_1_h_p_guard_t.html">details::HPGuard</a> &amp;&#160;</td>
          <td class="paramname"> <em>hp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Safely de-references <code>ppNode</code> link. </p>
<p>Safely de-references <code>ppNode</code> link and sets <code>hp</code> hazard pointer to the de-referenced node <code>TNODE</code> - class derived from <a class="el" href="classcds_1_1gc_1_1hrc_1_1_container_node.html" title="Base class for all HRC-based container&#39;s node.">ContainerNode</a> type </p>

</div>
</div>
<a class="anchor" id="ad2bd844b18bdb3b4e5e942f4363f4257"></a><!-- doxytag: member="cds::gc::hrc::ThreadGC::derefLink" ref="ad2bd844b18bdb3b4e5e942f4363f4257" args="(cds::details::marked_ptr&lt; TNODE, BITS &gt; *ppNode, ContainerNode *&amp;hp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TNODE , int BITS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcds_1_1details_1_1marked__ptr.html">cds::details::marked_ptr</a>&lt;TNODE, BITS&gt; cds::gc::hrc::ThreadGC::derefLink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1details_1_1marked__ptr.html">cds::details::marked_ptr</a>&lt; TNODE, BITS &gt; *&#160;</td>
          <td class="paramname"> <em>ppNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_container_node.html">ContainerNode</a> *&amp;&#160;</td>
          <td class="paramname"> <em>hp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Safely de-reference <code>ppNode</code> marked_node. </p>
<p>Safely de-references <code>ppNode</code> link and sets <code>hp</code> hazard pointer to the de-referenced node. <code>TNODE</code> - class derived from <a class="el" href="classcds_1_1gc_1_1hrc_1_1_container_node.html" title="Base class for all HRC-based container&#39;s node.">ContainerNode</a> type, wrapped by marked_ptr&lt;TNODE, BITS&gt; </p>

</div>
</div>
<a class="anchor" id="a57ac62d7423cdd7eee476c9118969869"></a><!-- doxytag: member="cds::gc::hrc::ThreadGC::releaseRef" ref="a57ac62d7423cdd7eee476c9118969869" args="(ContainerNode *&amp;hp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void cds::gc::hrc::ThreadGC::releaseRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_container_node.html">ContainerNode</a> *&amp;&#160;</td>
          <td class="paramname"> <em>hp</em>&#160;)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Releases reference. </p>
<p>The procedure should be called when a given node will not be accessed by the current thread anymore. It simply clears <code>hp</code> hazard pointer</p>
<p>Note that not all of containers that uses hrc GC schema calls this method. </p>

</div>
</div>
<a class="anchor" id="a47437ba0754704462a2a25a6194bea85"></a><!-- doxytag: member="cds::gc::hrc::ThreadGC::storeRef" ref="a47437ba0754704462a2a25a6194bea85" args="(TNODE *volatile *ppLink, TNODE *pNew)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TNODE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void cds::gc::hrc::ThreadGC::storeRef </td>
          <td>(</td>
          <td class="paramtype">TNODE *volatile *&#160;</td>
          <td class="paramname"> <em>ppLink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TNODE *&#160;</td>
          <td class="paramname"> <em>pNew</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updates <code>*ppLink</code> to new value <code>pNew</code> when no concurrent updates will be possible. </p>
<p><code>TNODE</code> - class derived from <a class="el" href="classcds_1_1gc_1_1hrc_1_1_container_node.html" title="Base class for all HRC-based container&#39;s node.">ContainerNode</a> type </p>

</div>
</div>
<a class="anchor" id="a71285d53056976dc0041960ed69202a2"></a><!-- doxytag: member="cds::gc::hrc::ThreadGC::xchgRef" ref="a71285d53056976dc0041960ed69202a2" args="(TNODE *volatile *ppLink, TNODE *pNew)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TNODE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static TNODE* cds::gc::hrc::ThreadGC::xchgRef </td>
          <td>(</td>
          <td class="paramtype">TNODE *volatile *&#160;</td>
          <td class="paramname"> <em>ppLink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TNODE *&#160;</td>
          <td class="paramname"> <em>pNew</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updates <code>*ppLink</code> node from any value to new value <code>pNew</code>. Returns old value of <code>*ppLink</code>. </p>
<p>May be used when concurrent updates is possible</p>
<p><code>TNODE</code> - class derived from <a class="el" href="classcds_1_1gc_1_1hrc_1_1_container_node.html" title="Base class for all HRC-based container&#39;s node.">ContainerNode</a> type </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/gc/hrc/hrc.h</li>
</ul>
</div>
		<hr/>
		<div align="right">
			<b>cds</b> <b>0.7.0</b> 
			Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2010
			<br/>
			<i>Autogenerated Sun Dec 5 2010 11:36:31 by Doxygen 1.7.2</i>
		</div>
	</BODY>
</HTML>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cds: cds::gc::tagged Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacecds.html">cds</a>      </li>
      <li><a class="el" href="namespacecds_1_1gc.html">gc</a>      </li>
      <li><a class="el" href="namespacecds_1_1gc_1_1tagged.html">tagged</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>cds::gc::tagged Namespace Reference</h1>  </div>
</div>
<div class="contents">

<p>Tagged pointer reclamation schema to solve ABA-problem.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1gc_1_1tagged_1_1tagged__type.html">tagged_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tagged data.  <a href="structcds_1_1gc_1_1tagged_1_1tagged__type.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1gc_1_1tagged_1_1_container_node.html">ContainerNode</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Base for tagged container node.  <a href="structcds_1_1gc_1_1tagged_1_1_container_node.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad32b1a00763a054a17984855519d7848"></a><!-- doxytag: member="cds::gc::tagged::ABA_tag" ref="ad32b1a00763a054a17984855519d7848" args="" -->
typedef <a class="el" href="namespacecds_1_1atomic__integrals.html#aca214c6c3fd2680e71552f88a71624d4">uptr_atomic_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecds_1_1gc_1_1tagged.html#ad32b1a00763a054a17984855519d7848">ABA_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type. <br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="abd0860611b16363490c11650cb8c7b34"></a><!-- doxytag: member="cds::gc::tagged::cas_tagged" ref="abd0860611b16363490c11650cb8c7b34" args="(tagged_type&lt; T &gt; volatile &amp;dest, const tagged_type&lt; T &gt; &amp;curVal, T dataNew, memory_order success_order, memory_order failure_order)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecds_1_1gc_1_1tagged.html#abd0860611b16363490c11650cb8c7b34">cas_tagged</a> (<a class="el" href="structcds_1_1gc_1_1tagged_1_1tagged__type.html">tagged_type</a>&lt; T &gt; volatile &amp;dest, const <a class="el" href="structcds_1_1gc_1_1tagged_1_1tagged__type.html">tagged_type</a>&lt; T &gt; &amp;curVal, T dataNew, <a class="el" href="namespacecds.html#a8616feae2dabb0a864b35db0f144466f">memory_order</a> success_order, <a class="el" href="namespacecds.html#a8616feae2dabb0a864b35db0f144466f">memory_order</a> failure_order)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">CAS specialization for tagged_type&lt;T&gt;. cas_tagged increments the counter of <code>curVal</code> on any call. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a1ecde40ebb317c0b73a4a9d39044fb09"></a><!-- doxytag: member="cds::gc::tagged::cas_tagged" ref="a1ecde40ebb317c0b73a4a9d39044fb09" args="(tagged_type&lt; T &gt; volatile &amp;dest, const tagged_type&lt; T &gt; &amp;curVal, T dataNew)" -->
template&lt;typename ORDER , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecds_1_1gc_1_1tagged.html#a1ecde40ebb317c0b73a4a9d39044fb09">cas_tagged</a> (<a class="el" href="structcds_1_1gc_1_1tagged_1_1tagged__type.html">tagged_type</a>&lt; T &gt; volatile &amp;dest, const <a class="el" href="structcds_1_1gc_1_1tagged_1_1tagged__type.html">tagged_type</a>&lt; T &gt; &amp;curVal, T dataNew)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">CAS specialization for tagged_type&lt;T&gt;. cas_tagged increments the counter of <code>curVal</code> on any call. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Tagged pointer reclamation schema to solve ABA-problem. </p>
<p>Tagged pointer reclamation schema was founded by IBM for resolving ABA problem of CAS-based algorithms. Each CASable pointer in this schema consists of two part: the pointer and the tag. The CAS operation atomically increments the tag any time when CAS is succeeded. In practice, it is means that the goal platform must support double-word CAS primitive. Tagged pointer is sufficiently efficient technique; unfortunately, not all of modern CPU architecture supports double-word CAS primitive; currently, only x86 and amd64 have full support of double-word CAS in 32-bit and 64-bit mode.</p>
<p>The macro CDS_DWORD_CAS_SUPPORTED is defined for the architecture that supports double-word CAS.</p>
<dl class="user"><dt><b>Implementation notes</b></dt><dd>It seems the tagged GC is not safe for complex data structure.</dd></dl>
<p>Consider the map based on tagged GC schema. Let's item's key is std::string (i.e. dynamically allocated buffer).</p>
<p>Thread F is seeking key K in the map. Suppose, it is preempted at the item with key K. Thread D deletes key K from the map. According to tagged GC, the item with key K places to the free-list. Notes, when a item is moved to the free-list the item's internal data (the string in our case) is not destroyed.</p>
<p>At the same time, the thread X inserts the key K in the map. It allocates new item from GC's free-list. Since the free-list is stack-based the item popped is the item that has just been deleted by the thread D. When an item is popped from the free-list, the destructor of internal data of the item must be called to clean it. Suppose, when item's destructor is processing, the thread F resumes and compares its current item with the key K. Oops! The current item for thread F is the item that is being destroy at this moment and item's key is K.</p>
<p>This case is one of typical problem of lock-free programming. For complex data structures, before an item can be reused we must be sure that no thread can access to it. The tagged GC saves us from ABA-problem but it does not solve "early reusing" problem.</p>
<p>For simple data structures tagged GC is safe. </p>
</div>
		<hr/>
		<div align="right">
			<b>cds</b> <b>0.7.0</b> 
			Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2010
			<br/>
			<i>Autogenerated Sun Dec 5 2010 11:36:31 by Doxygen 1.7.2</i>
		</div>
	</BODY>
</HTML>

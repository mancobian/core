<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cds: Data Structures</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Data Structures</h1>  </div>
</div>
<div class="contents">
Here are the data structures with brief descriptions:<table>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1details_1_1align__as.html">cds::details::align_as&lt; T, ALIGN_AS &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1_o_s_1_1aligned__allocator.html">cds::OS::aligned_allocator&lt; T &gt;</a></td><td class="indexvalue">Aligned allocator </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1details_1_1aligned__type.html">cds::details::aligned_type&lt; T, ALIGNMENT &gt;</a></td><td class="indexvalue">Aligned type </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1details_1_1_aligned_allocator.html">cds::details::AlignedAllocator&lt; T, ALIGNED_ALLOCATOR &gt;</a></td><td class="indexvalue"><a class="el" href="classcds_1_1details_1_1_allocator.html" title="Extends std::allocator interface to provide semantics like operator new and delete.">Allocator</a> for aligned data </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1details_1_1_allocator.html">cds::details::Allocator&lt; T, ALLOCATOR &gt;</a></td><td class="indexvalue">Extends <code>std::allocator</code> interface to provide semantics like operator <code>new</code> and <code>delete</code> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1any__type.html">cds::any_type</a></td><td class="indexvalue">Any_type is used as a placeholder for auto-calculated type (usually in <code>rebind</code> templates) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1atomic.html">cds::atomic&lt; T &gt;</a></td><td class="indexvalue">Atomic type </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1atomic_3_01_t_01_5_01_4.html">cds::atomic&lt; T * &gt;</a></td><td class="indexvalue">Atomic pointer </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1lock_1_1_auto.html">cds::lock::Auto&lt; T &gt;</a></td><td class="indexvalue"><a class="el" href="classcds_1_1lock_1_1_auto.html" title="Auto locker.">Auto</a> locker </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_auto_h_p_array.html">cds::gc::hzp::AutoHPArray&lt; COUNT &gt;</a></td><td class="indexvalue">Auto-managed array of hazard pointers </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_auto_h_p_array.html">cds::gc::hrc::AutoHPArray&lt; COUNT &gt;</a></td><td class="indexvalue">Auto-managed array of hazard pointers </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_auto_h_p_guard.html">cds::gc::hzp::AutoHPGuard</a></td><td class="indexvalue">Auto HPGuard </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_auto_h_p_guard.html">cds::gc::hrc::AutoHPGuard</a></td><td class="indexvalue">Auto HPGuard </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1lock_1_1_auto_unlock.html">cds::lock::AutoUnlock&lt; T &gt;</a></td><td class="indexvalue"><a class="el" href="classcds_1_1lock_1_1_auto.html" title="Auto locker.">Auto</a> unlocker </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1gc_1_1ptb_1_1details_1_1retired__ptr__pool_1_1block.html">cds::gc::ptb::details::retired_ptr_pool&lt; ALLOCATOR &gt;::block</a></td><td class="indexvalue">Pool block </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1concept_1_1bounded__container.html">cds::concept::bounded_container</a></td><td class="indexvalue">Bounded container </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1bucket__selector.html">cds::map::michael_map::details::bucket_selector&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;</a></td><td class="indexvalue">Helper class to define bucket and GC schema implementations </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1details_1_1_comparator.html">cds::details::Comparator&lt; T &gt;</a></td><td class="indexvalue"><a class="el" href="classcds_1_1details_1_1_comparator.html" title="Comparator.">Comparator</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1map_1_1split__list_1_1details_1_1split__list__base_1_1_comparator.html">cds::map::split_list::details::split_list_base&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::Comparator</a></td><td class="indexvalue">Regular key comparator </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1details_1_1_comparator_3_01std_1_1string_01_4.html">cds::details::Comparator&lt; std::string &gt;</a></td><td class="indexvalue">String specialization. It uses <em>string::compare</em> method </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1concept_1_1concurrent__iterator.html">cds::concept::concurrent_iterator&lt; T &gt;</a></td><td class="indexvalue">Base class for concurrent iterator of lock-free container implementation. <code>T</code> is type of data stored in container </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1concept_1_1concurrent__iterator__tag.html">cds::concept::concurrent_iterator_tag</a></td><td class="indexvalue">Iterator may be called in multi-threaded environment </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1gc_1_1ptb_1_1_container.html">cds::gc::ptb::Container&lt; NODE, ALLOCATOR &gt;</a></td><td class="indexvalue">The base for all containers based on the Pass-the-Buck GC </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_container.html">cds::gc::hrc::Container</a></td><td class="indexvalue">Base class for all HRC-based containers </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_container.html">cds::gc::hzp::Container&lt; NODE, ALLOCATOR &gt;</a></td><td class="indexvalue">The base for all containers based on the Hazard Pointers GC </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_container_node.html">cds::gc::hrc::ContainerNode</a></td><td class="indexvalue">Base class for all HRC-based container's node </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1gc_1_1tagged_1_1_container_node.html">cds::gc::tagged::ContainerNode&lt; T, NODE &gt;</a></td><td class="indexvalue">Base for tagged container node </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_container_node_t.html">cds::gc::hrc::ContainerNodeT&lt; T, ALLOCATOR &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1details_1_1deferral__deleter.html">cds::details::deferral_deleter&lt; T, ALLOCATOR &gt;</a></td><td class="indexvalue">Deferral removing of the object of type <code>T</code>. Helper class </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1map_1_1split__list_1_1details_1_1dummy__key.html">cds::map::split_list::details::dummy_key&lt; HASH_TYPE &gt;</a></td><td class="indexvalue">Dummy key of split-ordered list </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1queue_1_1dummy__statistics.html">cds::queue::dummy_statistics</a></td><td class="indexvalue">Empty queue statistics - does nothing. Support interface like as <a class="el" href="structcds_1_1queue_1_1queue__statistics.html" title="Queue internal statistics. May be used for debugging or profiling.">queue_statistics</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1map_1_1split__list_1_1dynamic__bucket__table.html">cds::map::split_list::dynamic_bucket_table&lt; T, ALLOCATOR &gt;</a></td><td class="indexvalue">Dynamic bucket table </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1backoff_1_1empty.html">cds::backoff::empty</a></td><td class="indexvalue">Empty backoff strategy. Do nothing </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1atomics_1_1empty__item__counter.html">cds::atomics::empty_item_counter</a></td><td class="indexvalue">Empty item counter </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1ordered__list_1_1empty__statistics.html">cds::ordered_list::empty_statistics</a></td><td class="indexvalue">Empty statistics of ordered list implementation </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1map_1_1empty__statistics.html">cds::map::empty_statistics</a></td><td class="indexvalue">Empty hash map statistics </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1map_1_1split__list_1_1empty__statistics.html">cds::map::split_list::empty_statistics</a></td><td class="indexvalue">Empty split-ordered list statistics </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1concept_1_1empty__type.html">cds::concept::empty_type</a></td><td class="indexvalue">Empty type </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1atomics_1_1event__counter.html">cds::atomics::event_counter</a></td><td class="indexvalue">Atomic event counter </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1_exception.html">cds::Exception</a></td><td class="indexvalue">Base of all exceptions in the library </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1beans_1_1_exponent2.html">cds::beans::Exponent2&lt; N &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1beans_1_1_exponent_n.html">cds::beans::ExponentN&lt; BASE, N &gt;</a></td><td class="indexvalue">Compile-time computing log(<code>N</code>) based <code>BASE</code>. Result in <em>Exponent&lt;BASE, N&gt;::result</em> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1free__list__traits.html">cds::ordered_list::details::michael_list_tagged::free_list_traits&lt; NODE, TRAITS &gt;</a></td><td class="indexvalue">Free-list traits </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1gc_1_1ptb_1_1_garbage_collector.html">cds::gc::ptb::GarbageCollector</a></td><td class="indexvalue">Memory manager (Garbage collector) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_garbage_collector.html">cds::gc::hrc::GarbageCollector</a></td><td class="indexvalue">Gidenstam's Garbage Collector </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html">cds::gc::hzp::GarbageCollector</a></td><td class="indexvalue">Hazard Pointer singleton </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1gc_1_1ptb_1_1details_1_1guard.html">cds::gc::ptb::details::guard</a></td><td class="indexvalue">Uninitialized guard </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1gc_1_1ptb_1_1_guard.html">cds::gc::ptb::Guard</a></td><td class="indexvalue"><a class="el" href="classcds_1_1gc_1_1ptb_1_1_guard.html" title="Guard.">Guard</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1gc_1_1ptb_1_1details_1_1guard__allocator.html">cds::gc::ptb::details::guard_allocator&lt; ALLOCATOR &gt;</a></td><td class="indexvalue"><a class="el" href="classcds_1_1gc_1_1ptb_1_1_guard.html" title="Guard.">Guard</a> allocator </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1gc_1_1ptb_1_1details_1_1guard__data.html">cds::gc::ptb::details::guard_data</a></td><td class="indexvalue">Internal guard representation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1gc_1_1ptb_1_1_guard_array.html">cds::gc::ptb::GuardArray&lt; COUNT &gt;</a></td><td class="indexvalue">Array of guards </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1map_1_1michael__map_1_1hash__table.html">cds::map::michael_map::hash_table&lt; GC, IMPL_SELECTOR, BUCKET_TYPE, ITEM_COUNTER, ALLOCATOR &gt;</a></td><td class="indexvalue">Hash table for <a class="el" href="classcds_1_1map_1_1_michael_hash_map.html" title="Michael&#39;s hash map.">MichaelHashMap</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1map_1_1michael__map_1_1hash__table_3_01gc_1_1tagged__gc_00_01boost_1_1false__type_00490bcbaa00cb1ec6db28ee2abf90811e.html">cds::map::michael_map::hash_table&lt; gc::tagged_gc, boost::false_type, BUCKET_TYPE, ITEM_COUNTER, ALLOCATOR &gt;</a></td><td class="indexvalue">Hash table specialization for <a class="el" href="structcds_1_1gc_1_1tagged__gc.html" title="Tag for Tagged Pointer reclamation schema.">gc::tagged_gc</a> GC </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1map_1_1michael__map_1_1hash__table_3_01gc_1_1tagged__gc_00_01boost_1_1true__type_00_9413449c9c563964ae9a04ad6fdd643e.html">cds::map::michael_map::hash_table&lt; gc::tagged_gc, boost::true_type, BUCKET_TYPE, ITEM_COUNTER, ALLOCATOR &gt;</a></td><td class="indexvalue">Hash table specialization for <a class="el" href="structcds_1_1gc_1_1tagged__gc.html" title="Tag for Tagged Pointer reclamation schema.">gc::tagged_gc</a> GC </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1hash__table__base.html">cds::map::michael_map::details::hash_table_base&lt; BUCKET_TYPE, ITEM_COUNTER, ALLOCATOR &gt;</a></td><td class="indexvalue">Hash table implementation for <a class="el" href="classcds_1_1map_1_1_michael_hash_map.html" title="Michael&#39;s hash map.">MichaelHashMap</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1threading_1_1pthread_1_1_manager_1_1_holder.html">cds::threading::pthread::Manager::Holder</a></td><td class="indexvalue">Pthread TLS key holder </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1gc_1_1hzp_1_1details_1_1_h_p_allocator.html">cds::gc::hzp::details::HPAllocator&lt; HPTYPE, ALLOCATOR &gt;</a></td><td class="indexvalue">Allocator of hazard pointers for the thread </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1gc_1_1hrc_1_1details_1_1_h_p_array.html">cds::gc::hrc::details::HPArray&lt; COUNT &gt;</a></td><td class="indexvalue">Array of hazard pointers </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1gc_1_1hzp_1_1details_1_1_h_p_array.html">cds::gc::hzp::details::HPArray&lt; COUNT &gt;</a></td><td class="indexvalue">Specialization of <a class="el" href="classcds_1_1gc_1_1hzp_1_1details_1_1_h_p_array_t.html" title="Array of hazard pointers.">HPArrayT</a> class for HazardPtr type </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1gc_1_1hzp_1_1details_1_1_h_p_array_t.html">cds::gc::hzp::details::HPArrayT&lt; HPTYPE, COUNT &gt;</a></td><td class="indexvalue">Array of hazard pointers </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1gc_1_1hzp_1_1details_1_1_h_p_guard_t.html">cds::gc::hzp::details::HPGuardT&lt; HPTYPE &gt;</a></td><td class="indexvalue">Hazard pointer guard </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1hplist__node.html">cds::gc::hzp::GarbageCollector::hplist_node</a></td><td class="indexvalue">Internal list of <a class="el" href="structcds_1_1gc_1_1hzp_1_1details_1_1_h_p_rec.html" title="Hazard pointer record of the thread.">cds::gc::hzp::details::HPRec</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1gc_1_1hzp_1_1details_1_1_h_p_rec.html">cds::gc::hzp::details::HPRec</a></td><td class="indexvalue">Hazard pointer record of the thread </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1gc_1_1hrc__gc.html">cds::gc::hrc_gc</a></td><td class="indexvalue">Tag for Gidenstam's memory reclamation schema </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1gc_1_1hzp__gc.html">cds::gc::hzp_gc</a></td><td class="indexvalue">Tag for Michael's Hazard Pointer reclamation schema </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1gc_1_1hrc_1_1_garbage_collector_1_1internal__state.html">cds::gc::hrc::GarbageCollector::internal_state</a></td><td class="indexvalue">GC internal statistics </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1gc_1_1ptb_1_1_garbage_collector_1_1_internal_state.html">cds::gc::ptb::GarbageCollector::InternalState</a></td><td class="indexvalue">Internal GC statistics </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1_internal_state.html">cds::gc::hzp::GarbageCollector::InternalState</a></td><td class="indexvalue">Internal GC statistics </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1atomics_1_1item__counter.html">cds::atomics::item_counter&lt; INC_ORDER, READ_ORDER &gt;</a></td><td class="indexvalue">Atomic item counter </td></tr>
  <tr><td class="indexkey"><a class="el" href="classboost_1_1iterator.html">iterator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1map_1_1key__traits.html">cds::map::key_traits&lt; KEY &gt;</a></td><td class="indexvalue">Key traits </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1ordered__list_1_1lazy__list__tag.html">cds::ordered_list::lazy_list_tag&lt; GC &gt;</a></td><td class="indexvalue">Selector for implementation of lazy ordered list </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1hrc__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_46a4c41ccc255c30dc33f23c641c36be.html">cds::ordered_list::LazyList&lt; gc::hrc_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;</a></td><td class="indexvalue">Lazy list specialization for Gidenstam's reference counting (<a class="el" href="structcds_1_1gc_1_1hrc__gc.html" title="Tag for Gidenstam&#39;s memory reclamation schema.">gc::hrc_gc</a>) memory reclamation schema </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1hzp__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_b3014471c63f1c90637dd68a0930b89f.html">cds::ordered_list::LazyList&lt; gc::hzp_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;</a></td><td class="indexvalue">Lazy list specialization for Hazard Pointer reclamation schema </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html">cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;</a></td><td class="indexvalue">Persistent (no item deletion) lazy list specialization </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1ptb__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_e7f2756c0f62cc0ad2451c4c3cc2b890.html">cds::ordered_list::LazyList&lt; gc::ptb_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;</a></td><td class="indexvalue">Lazy list specialization for Pass-the-Buck reclamation schema (<a class="el" href="namespacecds_1_1gc_1_1ptb.html" title="Pass The Buck reclamation schema.">cds::gc::ptb</a>) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html">cds::ordered_list::details::michael_list_tagged::list_base&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;</a></td><td class="indexvalue">Michael's ordered list with Tagged Pointer GC </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_l_m_s_queue.html">LMSQueue</a></td><td class="indexvalue">Ladan-Mozes &amp; Shavit optimistic queue </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1queue_1_1_l_m_s_queue_3_01gc_1_1hzp__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html">cds::queue::LMSQueue&lt; gc::hzp_gc, T, TRAITS, ALLOCATOR &gt;</a></td><td class="indexvalue">Ladan-Mozes &amp; Shavit optimistic queue based on Hazard Pointer (<a class="el" href="structcds_1_1gc_1_1hzp__gc.html" title="Tag for Michael&#39;s Hazard Pointer reclamation schema.">gc::hzp_gc</a>) reclamation schema </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1queue_1_1_l_m_s_queue_3_01gc_1_1ptb__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html">cds::queue::LMSQueue&lt; gc::ptb_gc, T, TRAITS, ALLOCATOR &gt;</a></td><td class="indexvalue">Ladan-Mozes &amp; Shavit optimistic queue based on Pass-The-Buck (<a class="el" href="structcds_1_1gc_1_1ptb__gc.html" title="Tag for &quot;Pass the Buck&quot; reclamation schema.">gc::ptb_gc</a>) reclamation schema </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1threading_1_1gcc_1_1_manager.html">cds::threading::gcc::Manager</a></td><td class="indexvalue">Thread-specific data manager based on GCC __thread feature </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1threading_1_1msvc_1_1_manager.html">cds::threading::msvc::Manager</a></td><td class="indexvalue">Thread-specific data manager based on MSVC __declspec( thread ) feature </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1threading_1_1pthread_1_1_manager.html">cds::threading::pthread::Manager</a></td><td class="indexvalue">Thread-specific data manager based on pthread thread-specific data functions </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1map_1_1map__base.html">cds::map::map_base&lt; KEY, VALUE, PAIR_TRAITS, TRAITS &gt;</a></td><td class="indexvalue">Base of any map implementation in the library </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1map_1_1map__tag.html">cds::map::map_tag</a></td><td class="indexvalue">This empty class is like a marker for the map implementations </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1details_1_1marked__ptr.html">cds::details::marked_ptr&lt; T, BITS &gt;</a></td><td class="indexvalue">Generic marked pointer </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1details_1_1marked__ptr_3_01_t_00_011_01_4.html">cds::details::marked_ptr&lt; T, 1 &gt;</a></td><td class="indexvalue">Marked pointer </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1beans_1_1_max.html">cds::beans::Max&lt; N1, N2 &gt;</a></td><td class="indexvalue">Returns max(N1, N2) as Max&lt;N1,N2&gt;::result </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1membar__acq__rel.html">cds::membar_acq_rel</a></td><td class="indexvalue">Wrapper for <a class="el" href="namespacecds.html#a8616feae2dabb0a864b35db0f144466fad0828a92ded697bca682312d9c7660b7">memory_order_acq_rel</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1membar__acquire.html">cds::membar_acquire</a></td><td class="indexvalue">Wrapper for <a class="el" href="namespacecds.html#a8616feae2dabb0a864b35db0f144466fa6e54d2c4510aa5fc7c7c495d3ca71a31">memory_order_acquire</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1membar__consume.html">cds::membar_consume</a></td><td class="indexvalue">Wrapper for <a class="el" href="namespacecds.html#a8616feae2dabb0a864b35db0f144466fa9e528b230a2d1af8a8b9ba4c42a8de12">memory_order_consume</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1membar__relaxed.html">cds::membar_relaxed</a></td><td class="indexvalue">Wrapper for <a class="el" href="namespacecds.html#a8616feae2dabb0a864b35db0f144466fa6b2ef59fd8a12da4d2eace0181f21760">memory_order_relaxed</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1membar__release.html">cds::membar_release</a></td><td class="indexvalue">Wrapper for <a class="el" href="namespacecds.html#a8616feae2dabb0a864b35db0f144466fa183e2154388b911965a76bbccf397bd4">memory_order_release</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1membar__seq__cst.html">cds::membar_seq_cst</a></td><td class="indexvalue">Wrapper for <a class="el" href="namespacecds.html#a8616feae2dabb0a864b35db0f144466fa688391e175cec6124cad8cf57a3c8585">memory_order_seq_cst</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1map_1_1split__list_1_1dynamic__bucket__table_1_1_metrics.html">cds::map::split_list::dynamic_bucket_table&lt; T, ALLOCATOR &gt;::Metrics</a></td><td class="indexvalue">Bucket table metrics </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1ordered__list_1_1michael__list__tag.html">cds::ordered_list::michael_list_tag&lt; GC &gt;</a></td><td class="indexvalue">Selector for implementation of Michael's ordered list </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html">cds::map::michael_map::details::michael_map_base&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;</a></td><td class="indexvalue">Base of Michael's hash map </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__gc.html">cds::map::michael_map::details::michael_map_gc&lt; GC, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;</a></td><td class="indexvalue">Michael's hash map implementation with support of item removing </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__gc_3_01gc_1_1no__gc_00_01_k_e_y_00_035e56e09eaf245e519ec7d1ffd8cdfec.html">cds::map::michael_map::details::michael_map_gc&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;</a></td><td class="indexvalue">Michael's hash map specialization without support of item removing </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1map_1_1_michael_hash_map.html">cds::map::MichaelHashMap&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;</a></td><td class="indexvalue">Michael's hash map </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1hrc__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p027a299af210d011b5ad6d172fa78529.html">cds::ordered_list::MichaelList&lt; gc::hrc_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;</a></td><td class="indexvalue">Lock-free ordered single-linked list developed by Michael based on Gidenstam's memory reclamation schema </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1hzp__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p6cdca608dcc728cc98fb8c2494896a89.html">cds::ordered_list::MichaelList&lt; gc::hzp_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;</a></td><td class="indexvalue">Lock-free ordered single-linked list developed by Michael based on Hazard Pointer reclamation schema </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html">cds::ordered_list::MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;</a></td><td class="indexvalue">Persistent (no deletion) Michael's ordered list </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1ptb__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_pad54a4baf1384968b9cf38998582ec00.html">cds::ordered_list::MichaelList&lt; gc::ptb_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;</a></td><td class="indexvalue">Lock-free ordered single-linked list developed by Michael based on "Pass-the-Buck reclamation schema </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1tagged__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_04767e1b50e2f21e8ab847279f5c5b4d9.html">cds::ordered_list::MichaelList&lt; gc::tagged_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;</a></td><td class="indexvalue">Lock-free ordered single-linked list developed by Michael </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1beans_1_1_min.html">cds::beans::Min&lt; N1, N2 &gt;</a></td><td class="indexvalue">Returns min(N1, N2) as Min&lt;N1,N2&gt;::result </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1queue_1_1details_1_1moir__queue__tagged.html">cds::queue::details::moir_queue_tagged&lt; T, TRAITS, FREELIST &gt;</a></td><td class="indexvalue">A variation of Michael's queue implementation based on IBM tag scheme </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1queue_1_1_moir_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html">cds::queue::MoirQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;</a></td><td class="indexvalue">A variation of Michael &amp; Scott lock-free queue (Gidenstam's GC) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1queue_1_1_moir_queue_3_01gc_1_1hzp__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html">cds::queue::MoirQueue&lt; gc::hzp_gc, T, TRAITS, ALLOCATOR &gt;</a></td><td class="indexvalue">A variation of Michael &amp; Scott lock-free queue based on Hazard Pointer GC </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1queue_1_1_moir_queue_3_01gc_1_1ptb__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html">cds::queue::MoirQueue&lt; gc::ptb_gc, T, TRAITS, ALLOCATOR &gt;</a></td><td class="indexvalue">A variation of Michael &amp; Scott lock-free queue based on Pass-The-Buck GC </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1queue_1_1_moir_queue_3_01gc_1_1tagged__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html">cds::queue::MoirQueue&lt; gc::tagged_gc, T, TRAITS, ALLOCATOR &gt;</a></td><td class="indexvalue">A variation of Michael &amp; Scott lock-free queue based on tagged pointer technique </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html">cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;</a></td><td class="indexvalue">Michael &amp; Scott lock-free queue implementation based on Gidenstam's memory reclamation schema (HRC) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hzp__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html">cds::queue::MSQueue&lt; gc::hzp_gc, T, TRAITS, ALLOCATOR &gt;</a></td><td class="indexvalue">Michael's Hazard Pointer queue </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1ptb__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html">cds::queue::MSQueue&lt; gc::ptb_gc, T, TRAITS, ALLOCATOR &gt;</a></td><td class="indexvalue">Michael's Pass-the-Buck queue </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1tagged__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html">cds::queue::MSQueue&lt; gc::tagged_gc, T, TRAITS, ALLOCATOR &gt;</a></td><td class="indexvalue">Implementation tagged Michael &amp; Scott queue based on tagged pointers methodology </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1queue_1_1details_1_1msqueue__node.html">cds::queue::details::msqueue_node&lt; T &gt;</a></td><td class="indexvalue">Michael's queue node. T - type stored in queue </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1gc_1_1no__gc.html">cds::gc::no_gc</a></td><td class="indexvalue">Tag for empty GC schema for lock-free objects without deletion of items (persistent data structure) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4_1_1_node.html">cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;::Node</a></td><td class="indexvalue">Queue node </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1queue_1_1details_1_1msqueue__tagged_1_1_node.html">cds::queue::details::msqueue_tagged::Node&lt; T &gt;</a></td><td class="indexvalue"><a class="el" href="structcds_1_1queue_1_1details_1_1msqueue__tagged_1_1_node.html" title="Node of MSQueue&lt;cds::gc::tagged_gc&gt;">Node</a> of MSQueue&lt;cds::gc::tagged_gc&gt; </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list_1_1_node_3_01gc_1_1no__gc_00_01_k_e_y_00_094949715463e026de5682c23764f9621.html">cds::ordered_list::details::michael_list::Node&lt; gc::no_gc, KEY, VALUE, ALLOCATOR &gt;</a></td><td class="indexvalue">Michael's list node for implementation without node deletion (no reclamation schema needed) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1lazy__list_1_1_node_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v06ee10a69f066ee68259a11ceaf25ab9.html">cds::ordered_list::details::lazy_list::Node&lt; gc::no_gc, KEY, VALUE, LOCK, ALLOCATOR &gt;</a></td><td class="indexvalue">Lazy list node for implementation without node deletion (no reclamation schema needed) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list_1_1_node_3_01gc_1_1tagged__gc_00_01_k_e_y_3260128262810d88e7ea7d0ded2611f8.html">cds::ordered_list::details::michael_list::Node&lt; gc::tagged_gc, KEY, VALUE, ALLOCATOR &gt;</a></td><td class="indexvalue">Node specialization for <a class="el" href="structcds_1_1gc_1_1tagged__gc.html" title="Tag for Tagged Pointer reclamation schema.">gc::tagged_gc</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1stack_1_1details_1_1node__hp.html">cds::stack::details::node_hp&lt; T &gt;</a></td><td class="indexvalue">Stack's node type for Hazard Pointer memory reclamation schema </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1concept_1_1non__concurrent__iterator.html">cds::concept::non_concurrent_iterator&lt; T &gt;</a></td><td class="indexvalue">Base class for non-concurrent forward iterator of lock-free container implementation. <code>T</code> is type of data stored in container </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1concept_1_1nonconcurrent__iterator__tag.html">cds::concept::nonconcurrent_iterator_tag</a></td><td class="indexvalue">Iterator cannot be called in multi-threaded environment </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base_1_1_non_concurrent_iterator.html">cds::map::michael_map::details::michael_map_base&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::NonConcurrentIterator&lt; VALUE_REF, ITERATOR &gt;</a></td><td class="indexvalue">Non-concurrent iterator </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_i7289b6aaed3ce884602afb7d19ee526c.html">cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::NonConcurrentIterator&lt; VALUE_REF &gt;</a></td><td class="indexvalue">Non-concurrent iterator </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_c632c02f297438a45373a97f8c1750fe.html">cds::ordered_list::MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::NonConcurrentIterator&lt; VALUE_REF &gt;</a></td><td class="indexvalue">Non-concurrent iterator </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_ad032c810027e074568b0da741bacd1c.html">cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;::NonConcurrentIterator&lt; Q &gt;</a></td><td class="indexvalue">Non-concurrent iterator class. Not thread-safe!!! For debugging only </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base_1_1_non_concurrent_iterator.html">cds::ordered_list::details::michael_list_tagged::list_base&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::NonConcurrentIterator&lt; VALUE_REF &gt;</a></td><td class="indexvalue">Non-concurrent iterator </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1queue_1_1details_1_1msqueue__tagged_1_1queue__impl_1_1_non_concurrent_iterator.html">cds::queue::details::msqueue_tagged::queue_impl&lt; T, TRAITS, FREELIST &gt;::NonConcurrentIterator&lt; Q &gt;</a></td><td class="indexvalue">Non-concurrent iterator class. Not thread-safe!!! For debugging only </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1queue_1_1_r_w_queue_1_1_non_concurrent_iterator.html">cds::queue::RWQueue&lt; T, LOCK, TRAITS, ALLOCATOR &gt;::NonConcurrentIterator&lt; Q &gt;</a></td><td class="indexvalue">Non-concurrent iterator class. Not thread-safe!!! For debugging only </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1map_1_1split__list_1_1details_1_1split__list__base_1_1_non_concurrent_iterator.html">cds::map::split_list::details::split_list_base&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::NonConcurrentIterator&lt; VALUE_REF, ITERATOR &gt;</a></td><td class="indexvalue">Non-concurrent iterator </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1ordered__list_1_1ordered__list__tag.html">cds::ordered_list::ordered_list_tag</a></td><td class="indexvalue">This empty class is like a marker for all ordered list implementations </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1ordered__list_1_1_ordered_list.html">cds::ordered_list::OrderedList&lt; KEY, VALUE, TRAITS &gt;</a></td><td class="indexvalue">Base of ordered list classes </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1map_1_1split__list_1_1details_1_1split__list__base_1_1ordlist__key__traits.html">cds::map::split_list::details::split_list_base&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::ordlist_key_traits</a></td><td class="indexvalue">Special split-ordered list key traits for ordered list implementation </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1map_1_1split__list_1_1details_1_1split__list__base_1_1ordlist__pair__traits.html">cds::map::split_list::details::split_list_base&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::ordlist_pair_traits</a></td><td class="indexvalue">Special split-ordered list pair traits for ordered list implementation </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_t_allocator_1_1template_01rebind_1_1other.html">other</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_a_l_l_o_c_a_t_o_r_1_1template_01rebind_1_1other.html">other</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_c_d_s___d_e_f_a_u_l_t___a_l_l_o_c_a_t_o_r_1_1template_01rebind_1_1other.html">other</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1map_1_1pair__traits.html">cds::map::pair_traits&lt; KEY, VALUE &gt;</a></td><td class="indexvalue">Pair (key, value) traits </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1backoff_1_1pause.html">cds::backoff::pause</a></td><td class="indexvalue">Random pause </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_eb2650d3ee7d1adec2e776b2db34a4a1.html">cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::Position</a></td><td class="indexvalue"><a class="el" href="structcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_eb2650d3ee7d1adec2e776b2db34a4a1.html" title="Position pointer for item search.">Position</a> pointer for item search </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1gc_1_1ptb__gc.html">cds::gc::ptb_gc</a></td><td class="indexvalue">Tag for "Pass the Buck" reclamation schema </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1threading_1_1pthread_1_1_manager_1_1pthread__exception.html">cds::threading::pthread::Manager::pthread_exception</a></td><td class="indexvalue">Pthread exception </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1queue_1_1details_1_1msqueue__tagged_1_1queue__impl.html">cds::queue::details::msqueue_tagged::queue_impl&lt; T, TRAITS, FREELIST &gt;</a></td><td class="indexvalue">Michael's queue implementation based on on ABA-prevention tag (IBM tagged pointers) scheme </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1queue_1_1queue__statistics.html">cds::queue::queue_statistics</a></td><td class="indexvalue">Queue internal statistics. May be used for debugging or profiling </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1ordered__list_1_1details_1_1lazy__list_1_1_node_3_01gc_1_1no__gc_00_01_k_e_y_00_01_180a2b29ed271c595fb9bf8049c83ed5.html">cds::ordered_list::details::lazy_list::Node&lt; gc::no_gc, KEY, VALUE, LOCK, ALLOCATOR &gt;::rebind&lt; KEY2, VALUE2, LOCK2 &gt;</a></td><td class="indexvalue">Rebind key/value type </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1hrc__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a55298a30f8af525694829658c6b6e890.html">cds::ordered_list::LazyList&lt; gc::hrc_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::rebind&lt; KEY2, VALUE2, PAIR_TRAITS2, TRAITS2 &gt;</a></td><td class="indexvalue">Rebind type of key-value pair stored in the list </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_94f39b22b0cbaaec8f0b703c7683bf8e.html">cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::rebind&lt; KEY2, VALUE2, PAIR_TRAITS2, TRAITS2 &gt;</a></td><td class="indexvalue">Rebind type of key-value pair stored in the list </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1ptb__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_aeb997680c69274d5ededd43bdbf11f32.html">cds::ordered_list::LazyList&lt; gc::ptb_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::rebind&lt; KEY2, VALUE2, PAIR_TRAITS2, TRAITS2 &gt;</a></td><td class="indexvalue">Rebind type of key-value pair stored in the list </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1gc_1_1hzp_1_1_auto_h_p_array_1_1rebind.html">cds::gc::hzp::AutoHPArray&lt; COUNT &gt;::rebind&lt; COUNT2 &gt;</a></td><td class="indexvalue">Rebind array for other size <code>COUNT2</code> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1ordered__list_1_1details_1_1michael__list_1_1_node_3_01gc_1_1no__gc_00_01_k_e_y_00_a705d6ce82099037602f4693cb8f0b41.html">cds::ordered_list::details::michael_list::Node&lt; gc::no_gc, KEY, VALUE, ALLOCATOR &gt;::rebind&lt; KEY2, VALUE2 &gt;</a></td><td class="indexvalue">Rebind key/value type </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1gc_1_1ptb_1_1_guard_array_1_1rebind.html">cds::gc::ptb::GuardArray&lt; COUNT &gt;::rebind&lt; COUNT2 &gt;</a></td><td class="indexvalue">Rebind array for other size <code>COUNT2</code> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1ptb__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_faac9a222be271a5c6a71de3e531f511.html">cds::ordered_list::MichaelList&lt; gc::ptb_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::rebind&lt; KEY2, VALUE2, PAIR_TRAITS2, TRAITS2 &gt;</a></td><td class="indexvalue">Rebind type of key-value pair stored in the list </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1hrc__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_e71de3d64c1d1a7e69454e763910314a.html">cds::ordered_list::MichaelList&lt; gc::hrc_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::rebind&lt; KEY2, VALUE2, PAIR_TRAITS2, TRAITS2 &gt;</a></td><td class="indexvalue">Rebind type of key-value pair stored in the list </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1_o_s_1_1aligned__allocator_1_1rebind.html">cds::OS::aligned_allocator&lt; T &gt;::rebind&lt; OTHER &gt;</a></td><td class="indexvalue">Convert an aligned_allocator&lt;T&gt; to an aligned_allocator&lt;OTHER&gt; </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1details_1_1_aligned_allocator_1_1rebind.html">cds::details::AlignedAllocator&lt; T, ALIGNED_ALLOCATOR &gt;::rebind&lt; Q &gt;</a></td><td class="indexvalue">Rebinds allocator to other type <code>Q</code> instead of <code>T</code> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1hzp__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_af98ae1ddf13221cf79b20431675da08e.html">cds::ordered_list::LazyList&lt; gc::hzp_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::rebind&lt; KEY2, VALUE2, PAIR_TRAITS2, TRAITS2 &gt;</a></td><td class="indexvalue">Rebind type of key-value pair stored in the list </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1details_1_1_allocator_1_1rebind.html">cds::details::Allocator&lt; T, ALLOCATOR &gt;::rebind&lt; Q &gt;</a></td><td class="indexvalue">Rebinds allocator to other type <code>Q</code> instead of <code>T</code> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1map_1_1split__list_1_1static__bucket__table_1_1rebind.html">cds::map::split_list::static_bucket_table&lt; T, ALLOCATOR &gt;::rebind&lt; Q &gt;</a></td><td class="indexvalue">Rebind bucket table to other bucket type Q </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p32deab6d69d69403194256e5bdb3c003.html">cds::ordered_list::MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::rebind&lt; KEY2, VALUE2, PAIR_TRAITS2, TRAITS2 &gt;</a></td><td class="indexvalue">Rebind type of key-value pair stored in the list </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1tagged__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_2677c70daa5d05443d1d3cb5366727e3.html">cds::ordered_list::MichaelList&lt; gc::tagged_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::rebind&lt; KEY2, VALUE2, PAIR_TRAITS2, TRAITS2 &gt;</a></td><td class="indexvalue">Rebind type of key-value pair stored in the list </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1map_1_1split__list_1_1dynamic__bucket__table_1_1rebind.html">cds::map::split_list::dynamic_bucket_table&lt; T, ALLOCATOR &gt;::rebind&lt; Q &gt;</a></td><td class="indexvalue">Rebind bucket table to other bucket type Q </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1ordered__list_1_1details_1_1michael__list_1_1_node_3_01gc_1_1tagged__gc_00_01_k_e_y294af966cd18d077ce177d0393472104.html">cds::ordered_list::details::michael_list::Node&lt; gc::tagged_gc, KEY, VALUE, ALLOCATOR &gt;::rebind&lt; KEY2, VALUE2 &gt;</a></td><td class="indexvalue">Rebind key/value type </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1hzp__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_e4d0cfb2e99452fcfab428472e07b33c.html">cds::ordered_list::MichaelList&lt; gc::hzp_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::rebind&lt; KEY2, VALUE2, PAIR_TRAITS2, TRAITS2 &gt;</a></td><td class="indexvalue">Rebind type of key-value pair stored in the list </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html">cds::lock::ReentrantSpinT&lt; ATOMIC, BACKOFF &gt;</a></td><td class="indexvalue">Recursive spin lock </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1ref__counter.html">cds::ref_counter&lt; T &gt;</a></td><td class="indexvalue">Simple reference counter </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1map_1_1split__list_1_1details_1_1regular__key.html">cds::map::split_list::details::regular_key&lt; KEY, HASH_TYPE &gt;</a></td><td class="indexvalue">Regular key of split-ordered list </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1gc_1_1hrc_1_1details_1_1retired__node.html">cds::gc::hrc::details::retired_node</a></td><td class="indexvalue">Retired node descriptor </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1gc_1_1details_1_1retired__ptr.html">cds::gc::details::retired_ptr</a></td><td class="indexvalue">Retired pointer </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1gc_1_1ptb_1_1details_1_1retired__ptr__buffer.html">cds::gc::ptb::details::retired_ptr_buffer</a></td><td class="indexvalue">Retired pointer buffer </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1gc_1_1ptb_1_1details_1_1retired__ptr__node.html">cds::gc::ptb::details::retired_ptr_node</a></td><td class="indexvalue">Retired pointer buffer node </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1gc_1_1ptb_1_1details_1_1retired__ptr__pool.html">cds::gc::ptb::details::retired_ptr_pool&lt; ALLOCATOR &gt;</a></td><td class="indexvalue">Pool of retired pointers </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1gc_1_1hrc_1_1details_1_1retired__vector.html">cds::gc::hrc::details::retired_vector</a></td><td class="indexvalue">Array of ready for destroying pointers </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1gc_1_1hzp_1_1details_1_1retired__vector.html">cds::gc::hzp::details::retired_vector</a></td><td class="indexvalue">Array of retired pointers </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1queue_1_1_r_w_queue.html">cds::queue::RWQueue&lt; T, LOCK, TRAITS, ALLOCATOR &gt;</a></td><td class="indexvalue">Michael &amp; Scott blocking queue with fine-grained synchronization schema </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1queue_1_1details_1_1rwqueue__node.html">cds::queue::details::rwqueue_node&lt; T &gt;</a></td><td class="indexvalue">RWQueueT node </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1lock_1_1_spin_t.html">cds::lock::SpinT&lt; ATOMIC, BACKOFF &gt;</a></td><td class="indexvalue">Spin lock </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1map_1_1split__list_1_1details_1_1split__list__base.html">cds::map::split_list::details::split_list_base&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;</a></td><td class="indexvalue">Split-ordered list implementation base </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1map_1_1split__list_1_1details_1_1split__list__impl_3_01false_00_01_k_e_y_00_01_v_a_l1ca1d58113798f53a3a68a1f8fe4910f.html">cds::map::split_list::details::split_list_impl&lt; false, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;</a></td><td class="indexvalue">Split ordered list without support of node deletion </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1map_1_1split__list_1_1details_1_1split__list__impl_3_01true_00_01_k_e_y_00_01_v_a_l_66913a95eabdab73b9e7efc7682a5897.html">cds::map::split_list::details::split_list_impl&lt; true, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;</a></td><td class="indexvalue">Split ordered list with support of node deletion </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1map_1_1split__list_1_1details_1_1split__list__selector.html">cds::map::split_list::details::split_list_selector&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;</a></td><td class="indexvalue">Split-ordered list implementation selector </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1map_1_1_split_ordered_list.html">cds::map::SplitOrderedList&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;</a></td><td class="indexvalue">Split-ordered list </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1stack_1_1_stack_3_01gc_1_1hzp__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html">cds::stack::Stack&lt; gc::hzp_gc, T, TRAITS, ALLOCATOR &gt;</a></td><td class="indexvalue">Lock-free stack based on Hazard Pointer schema </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1stack_1_1_stack_3_01gc_1_1tagged__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html">cds::stack::Stack&lt; gc::tagged_gc, T, TRAITS, ALLOCATOR &gt;</a></td><td class="indexvalue">Lock-free stack based on IBM tag methodology </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1map_1_1split__list_1_1static__bucket__table.html">cds::map::split_list::static_bucket_table&lt; T, ALLOCATOR &gt;</a></td><td class="indexvalue">Static bucket table </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1map_1_1split__list_1_1statistics.html">cds::map::split_list::statistics</a></td><td class="indexvalue">Split-ordered list statistics </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1gc_1_1hrc_1_1_garbage_collector_1_1statistics.html">cds::gc::hrc::GarbageCollector::statistics</a></td><td class="indexvalue">Internal statistics by events </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1_statistics.html">cds::gc::hzp::GarbageCollector::Statistics</a></td><td class="indexvalue">Internal GC statistics </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1ordered__list_1_1_statistics.html">cds::ordered_list::Statistics</a></td><td class="indexvalue">Internal statistics of ordered list implementation </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1gc_1_1tagged__gc.html">cds::gc::tagged_gc</a></td><td class="indexvalue">Tag for Tagged Pointer reclamation schema </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1gc_1_1tagged_1_1tagged__type.html">cds::gc::tagged::tagged_type&lt; T &gt;</a></td><td class="indexvalue">Tagged data </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1gc_1_1hrc_1_1details_1_1thread__descriptor.html">cds::gc::hrc::details::thread_descriptor</a></td><td class="indexvalue">HP record of the thread </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1gc_1_1hrc_1_1_garbage_collector_1_1thread__list__node.html">cds::gc::hrc::GarbageCollector::thread_list_node</a></td><td class="indexvalue">HRC control structure of global thread list </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1threading_1_1_thread_data.html">cds::threading::ThreadData</a></td><td class="indexvalue">Thread-specific data </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_thread_g_c.html">cds::gc::hrc::ThreadGC</a></td><td class="indexvalue">Thread's Garbage collector </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_thread_g_c.html">cds::gc::hzp::ThreadGC</a></td><td class="indexvalue">Thread's hazard pointer manager </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1gc_1_1ptb_1_1_thread_g_c.html">cds::gc::ptb::ThreadGC</a></td><td class="indexvalue">Thread GC </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1queue_1_1traits.html">cds::queue::traits</a></td><td class="indexvalue">Traits struct defines types for queue implementations </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1stack_1_1_traits.html">cds::stack::Traits</a></td><td class="indexvalue">Lock-free stack traits </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcds_1_1details_1_1type__padding.html">cds::details::type_padding&lt; T, ALIGN_FACTOR &gt;</a></td><td class="indexvalue">Automatic alignment type <code>T</code> to <code>ALIGN_FACTOR</code> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1map_1_1split__list_1_1type__traits.html">cds::map::split_list::type_traits</a></td><td class="indexvalue">Split-Ordered list type traits </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1queue_1_1details_1_1msqueue__tagged_1_1queue__impl_1_1type__traits.html">cds::queue::details::msqueue_tagged::queue_impl&lt; T, TRAITS, FREELIST &gt;::type_traits</a></td><td class="indexvalue">Type traits </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_598524d2a813c43b7d737e8e4c650900.html">cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::type_traits</a></td><td class="indexvalue">Ordered list traits </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1ordered__list_1_1type__traits.html">cds::ordered_list::type_traits</a></td><td class="indexvalue">Ordered list default type traits class </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base_1_1type__traits.html">cds::map::michael_map::details::michael_map_base&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::type_traits</a></td><td class="indexvalue">Map traits </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1tagged__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_729abd22634dfed4b8b8fa01906be4ba.html">cds::ordered_list::MichaelList&lt; gc::tagged_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::type_traits</a></td><td class="indexvalue">List type traits </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1map_1_1type__traits.html">cds::map::type_traits</a></td><td class="indexvalue">Generic map traits </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p7184a9ccda001877668cc8aca1908d25.html">cds::ordered_list::MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::type_traits</a></td><td class="indexvalue">List type traits </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1map_1_1split__list_1_1details_1_1split__list__base_1_1type__traits.html">cds::map::split_list::details::split_list_base&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::type_traits</a></td><td class="indexvalue">Split-list traits </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base_1_1type__traits.html">cds::ordered_list::details::michael_list_tagged::list_base&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::type_traits</a></td><td class="indexvalue">List type traits </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1ordered__list_1_1type__traits__selector.html">cds::ordered_list::type_traits_selector&lt; TRAITS &gt;</a></td><td class="indexvalue">Ordered list type traits selector </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1map_1_1value__traits.html">cds::map::value_traits&lt; T &gt;</a></td><td class="indexvalue">Value traits </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1details_1_1void__selector.html">cds::details::void_selector&lt; T, TVOID, TNOVOID &gt;</a></td><td class="indexvalue">Void type selector </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcds_1_1backoff_1_1yield.html">cds::backoff::yield</a></td><td class="indexvalue">Switch to another thread (yield). Good for thread preemption architecture </td></tr>
</table>
</div>
		<hr/>
		<div align="right">
			<b>cds</b> <b>0.7.0</b> 
			Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2010
			<br/>
			<i>Autogenerated Sun Dec 5 2010 11:36:28 by Doxygen 1.7.2</i>
		</div>
	</BODY>
</HTML>

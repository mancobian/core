<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cds: cds::lock::ReentrantSpinT&lt; ATOMIC, BACKOFF &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacecds.html">cds</a>      </li>
      <li><a class="el" href="namespacecds_1_1lock.html">lock</a>      </li>
      <li><a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html">ReentrantSpinT</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<h1>cds::lock::ReentrantSpinT&lt; ATOMIC, BACKOFF &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="cds::lock::ReentrantSpinT" -->
<p>Recursive spin lock.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;spinlock.h&gt;</code></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1a8d3c956bc56d3403e3256c8847d55"></a><!-- doxytag: member="cds::lock::ReentrantSpinT::atomic_type" ref="ab1a8d3c956bc56d3403e3256c8847d55" args="" -->
typedef ATOMIC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html#ab1a8d3c956bc56d3403e3256c8847d55">atomic_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The atomic type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac57c7ef34d01d6352db3762efa4c5844"></a><!-- doxytag: member="cds::lock::ReentrantSpinT::backoff_strategy" ref="ac57c7ef34d01d6352db3762efa4c5844" args="" -->
typedef BACKOFF&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html#ac57c7ef34d01d6352db3762efa4c5844">backoff_strategy</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The backoff type. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42eb62d5b21c7177bcc13ac54b4f4625"></a><!-- doxytag: member="cds::lock::ReentrantSpinT::ReentrantSpinT" ref="a42eb62d5b21c7177bcc13ac54b4f4625" args="()" -->
CDS_CONSTEXPR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html#a42eb62d5b21c7177bcc13ac54b4f4625">ReentrantSpinT</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor initializes spin to free (unlocked) state. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html#a321e782a001aac731cb0cb2b452bf08d">ReentrantSpinT</a> (const <a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html">ReentrantSpinT</a>&lt; ATOMIC, BACKOFF &gt; &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy copy constructor.  <a href="#a321e782a001aac731cb0cb2b452bf08d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1e3dabc7198568129f3b10272907a5f"></a><!-- doxytag: member="cds::lock::ReentrantSpinT::ReentrantSpinT" ref="aa1e3dabc7198568129f3b10272907a5f" args="(bool bLocked)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html#aa1e3dabc7198568129f3b10272907a5f">ReentrantSpinT</a> (bool bLocked)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct object for specified state. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7c7bf2727c132961cbd427d9c7ff104"></a><!-- doxytag: member="cds::lock::ReentrantSpinT::tryLock" ref="ac7c7bf2727c132961cbd427d9c7ff104" args="()" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html#ac7c7bf2727c132961cbd427d9c7ff104">tryLock</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to lock the spin-lock. If spin-lock is free the current thread owns it. Return <code>true</code> if lock is success. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html#a4a05bea1789cd8f5239dba5dee6a64a4">tryLock</a> (unsigned int nTryCount)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to lock the object.  <a href="#a4a05bea1789cd8f5239dba5dee6a64a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a8630ecf7b1a020bae7da4a864118e5"></a><!-- doxytag: member="cds::lock::ReentrantSpinT::lock" ref="a4a8630ecf7b1a020bae7da4a864118e5" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html#a4a8630ecf7b1a020bae7da4a864118e5">lock</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the object waits if it is busy. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb0c1993bde4a30a14dd09591957e19c"></a><!-- doxytag: member="cds::lock::ReentrantSpinT::unlock" ref="aeb0c1993bde4a30a14dd09591957e19c" args="()" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html#aeb0c1993bde4a30a14dd09591957e19c">unlock</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the spin-lock. Return <code>true</code> if the current thread is owner of spin-lock <code>false</code> otherwise. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b3ef354d53bd0706193706c3cfe1364"></a><!-- doxytag: member="cds::lock::ReentrantSpinT::changeOwner" ref="a5b3ef354d53bd0706193706c3cfe1364" args="(OS::ThreadId newOwnerId)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html#a5b3ef354d53bd0706193706c3cfe1364">changeOwner</a> (OS::ThreadId newOwnerId)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the owner of locked spin-lock. May be called by thread that is owner of the spin-lock. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2dd26e691630b091ab319a80a6aac63a"></a><!-- doxytag: member="cds::lock::ReentrantSpinT::thread_id" ref="a2dd26e691630b091ab319a80a6aac63a" args="" -->
typedef OS::ThreadId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html#a2dd26e691630b091ab319a80a6aac63a">thread_id</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of thread id. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae0b68e31a3e5146b751da1a0a9a7eb9"></a><!-- doxytag: member="cds::lock::ReentrantSpinT::m_spin" ref="aae0b68e31a3e5146b751da1a0a9a7eb9" args="" -->
<a class="el" href="classcds_1_1atomic.html">atomic</a>&lt; <a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html#ab1a8d3c956bc56d3403e3256c8847d55">atomic_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html#aae0b68e31a3e5146b751da1a0a9a7eb9">m_spin</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">spin-lock atomic <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08c8b30bec23b8e47b97649baadd7527"></a><!-- doxytag: member="cds::lock::ReentrantSpinT::m_OwnerId" ref="a08c8b30bec23b8e47b97649baadd7527" args="" -->
<a class="el" href="classcds_1_1atomic.html">atomic</a>&lt; <a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html#a2dd26e691630b091ab319a80a6aac63a">thread_id</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html#a08c8b30bec23b8e47b97649baadd7527">m_OwnerId</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Owner thread id. If spin-lock is not locked it usually equals to OS::nullThreadId() <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename ATOMIC, class BACKOFF&gt;<br/>
 class cds::lock::ReentrantSpinT&lt; ATOMIC, BACKOFF &gt;</h3>

<p>Recursive spin lock. </p>
<p>Allows recursive calls: the owner thread may recursive enter to critical section guarded by the spin-lock.</p>
<p>Template parameters:</p>
<ul>
<li><code>ATOMIC</code> one of integral atomic type: atomic_t, atomic32_t, atomic32u_t and others</li>
<li><code>BACKOFF</code> backoff strategy. Used when spin lock is locked </li>
</ul>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a321e782a001aac731cb0cb2b452bf08d"></a><!-- doxytag: member="cds::lock::ReentrantSpinT::ReentrantSpinT" ref="a321e782a001aac731cb0cb2b452bf08d" args="(const ReentrantSpinT&lt; ATOMIC, BACKOFF &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ATOMIC , class BACKOFF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html">cds::lock::ReentrantSpinT</a>&lt; ATOMIC, BACKOFF &gt;::<a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html">ReentrantSpinT</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html">ReentrantSpinT</a>&lt; ATOMIC, BACKOFF &gt; &amp;&#160;</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dummy copy constructor. </p>
<p>In theory, spin-lock cannot be copied. However, it is not practical. Therefore, we provide dummy copy constructor that do no copy in fact. The ctor initializes the spin to free (unlocked) state like default ctor. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a4a05bea1789cd8f5239dba5dee6a64a4"></a><!-- doxytag: member="cds::lock::ReentrantSpinT::tryLock" ref="a4a05bea1789cd8f5239dba5dee6a64a4" args="(unsigned int nTryCount)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ATOMIC , class BACKOFF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html">cds::lock::ReentrantSpinT</a>&lt; ATOMIC, BACKOFF &gt;::tryLock </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"> <em>nTryCount</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Try to lock the object. </p>
<p>If spin-lock is locked the method repeats attempts to own spin-lock up to <code>nTryCount</code> times. Between attempts <code>backoff()</code> is called. Return <code>true</code> if current thread owns the lock <code>false</code> otherwise </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/lock/spinlock.h</li>
</ul>
</div>
		<hr/>
		<div align="right">
			<b>cds</b> <b>0.7.0</b> 
			Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2010
			<br/>
			<i>Autogenerated Sun Dec 5 2010 11:36:31 by Doxygen 1.7.2</i>
		</div>
	</BODY>
</HTML>

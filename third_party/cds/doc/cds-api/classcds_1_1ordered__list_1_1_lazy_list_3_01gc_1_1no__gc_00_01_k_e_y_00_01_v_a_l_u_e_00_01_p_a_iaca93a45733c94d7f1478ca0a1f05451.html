<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cds: cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacecds.html">cds</a>      </li>
      <li><a class="el" href="namespacecds_1_1ordered__list.html">ordered_list</a>      </li>
      <li><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html">LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a>  </div>
  <div class="headertitle">
<h1>cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;" --><!-- doxytag: inherits="cds::ordered_list::OrderedList,lazy_list_tag&lt; gc::no_gc &gt;" -->
<p>Persistent (no item deletion) lazy list specialization.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;lazy_list_nogc.h&gt;</code></p>
<!-- startSectionHeader --><div class="dynheader">
Inheritance diagram for cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;:<!-- endSectionHeader --></div>
<!-- startSectionSummary --><!-- endSectionSummary --><!-- startSectionContent --><div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.png" usemap="#cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;_map" alt=""/>
  <map id="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;_map" name="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;_map">
<area href="structcds_1_1ordered__list_1_1_ordered_list.html" alt="cds::ordered_list::OrderedList&lt; KEY, VALUE, TRAITS &gt;" shape="rect" coords="0,56,542,80"/>
<area href="structcds_1_1ordered__list_1_1lazy__list__tag.html" alt="cds::ordered_list::lazy_list_tag&lt; gc::no_gc &gt;" shape="rect" coords="552,56,1094,80"/>
<area href="structcds_1_1ordered__list_1_1ordered__list__tag.html" alt="cds::ordered_list::ordered_list_tag" shape="rect" coords="0,0,542,24"/>
</map>
 </div><!-- endSectionContent --></div>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_i7289b6aaed3ce884602afb7d19ee526c.html">NonConcurrentIterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-concurrent iterator.  <a href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_i7289b6aaed3ce884602afb7d19ee526c.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_eb2650d3ee7d1adec2e776b2db34a4a1.html">Position</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_eb2650d3ee7d1adec2e776b2db34a4a1.html" title="Position pointer for item search.">Position</a> pointer for item search.  <a href="structcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_eb2650d3ee7d1adec2e776b2db34a4a1.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_94f39b22b0cbaaec8f0b703c7683bf8e.html">rebind</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebind type of key-value pair stored in the list.  <a href="structcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_94f39b22b0cbaaec8f0b703c7683bf8e.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_598524d2a813c43b7d737e8e4c650900.html">type_traits</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordered list traits.  <a href="structcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_598524d2a813c43b7d737e8e4c650900.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42283bb56c836854f627fdeef6980e0e"></a><!-- doxytag: member="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::gc_schema" ref="a42283bb56c836854f627fdeef6980e0e" args="" -->
typedef <a class="el" href="structcds_1_1gc_1_1no__gc.html">gc::no_gc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a42283bb56c836854f627fdeef6980e0e">gc_schema</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collection schema. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d1b5dea05bd49a8444bdfaebcfbefec"></a><!-- doxytag: member="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::Node" ref="a9d1b5dea05bd49a8444bdfaebcfbefec" args="" -->
typedef <br class="typebreak"/>
details::lazy_list::Node<br class="typebreak"/>
&lt; <a class="el" href="structcds_1_1gc_1_1no__gc.html">gc_schema</a>, KEY, VALUE, <br class="typebreak"/>
lock_impl, ALLOCATOR &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a9d1b5dea05bd49a8444bdfaebcfbefec">Node</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">List node type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9de5acf47b64f216d66d435253fa751"></a><!-- doxytag: member="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::key_type" ref="ae9de5acf47b64f216d66d435253fa751" args="" -->
typedef base_class::key_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#ae9de5acf47b64f216d66d435253fa751">key_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Key type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad8e9ad748203372e9811b4165648a3a"></a><!-- doxytag: member="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::value_type" ref="aad8e9ad748203372e9811b4165648a3a" args="" -->
typedef base_class::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#aad8e9ad748203372e9811b4165648a3a">value_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1ed6951f2ff48dbafac17b83a69843f"></a><!-- doxytag: member="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::pair_traits" ref="af1ed6951f2ff48dbafac17b83a69843f" args="" -->
typedef PAIR_TRAITS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#af1ed6951f2ff48dbafac17b83a69843f">pair_traits</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pair traits type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b0c2ee89388bbc6e3afefc3568c6f60"></a><!-- doxytag: member="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::key_traits" ref="a3b0c2ee89388bbc6e3afefc3568c6f60" args="" -->
typedef pair_traits::key_traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a3b0c2ee89388bbc6e3afefc3568c6f60">key_traits</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Key traits. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27f50cf4566499a9c7cc1a6bf4d8c187"></a><!-- doxytag: member="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::value_traits" ref="a27f50cf4566499a9c7cc1a6bf4d8c187" args="" -->
typedef pair_traits::value_traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a27f50cf4566499a9c7cc1a6bf4d8c187">value_traits</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Value traits. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a146cc389a228e6b90c442f446d6b2f90"></a><!-- doxytag: member="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::key_comparator" ref="a146cc389a228e6b90c442f446d6b2f90" args="" -->
typedef key_traits::key_comparator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a146cc389a228e6b90c442f446d6b2f90">key_comparator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Key comparator (binary predicate) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c828e5c5008bcf131b929ca60fbcae0"></a><!-- doxytag: member="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::node_allocator" ref="a2c828e5c5008bcf131b929ca60fbcae0" args="" -->
typedef Node::node_allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a2c828e5c5008bcf131b929ca60fbcae0">node_allocator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">node allocator <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef NonConcurrentIterator<br class="typebreak"/>
&lt; <a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#aad8e9ad748203372e9811b4165648a3a">value_type</a> &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a7aeda4b2f6134902c003947371397a5c">nonconcurrent_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-concurrent iterator.  <a href="#a7aeda4b2f6134902c003947371397a5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef NonConcurrentIterator<br class="typebreak"/>
&lt; const <a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#aad8e9ad748203372e9811b4165648a3a">value_type</a> &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#aab9c849ce3405387e62bd2bbccc008b1">nonconcurrent_const_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-concurrent iterator.  <a href="#aab9c849ce3405387e62bd2bbccc008b1"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a926f3730aafbea2eb5c50712fc4517c4">insert</a> (const KEY &amp;key, const VALUE &amp;data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a926f3730aafbea2eb5c50712fc4517c4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="af4970c918f9965e4de0d923cb921d115"></a><!-- doxytag: member="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::ensure" ref="af4970c918f9965e4de0d923cb921d115" args="(const KEY &amp;key, const VALUE &amp;val, FUNC func)" -->
template&lt;typename FUNC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#af4970c918f9965e4de0d923cb921d115">ensure</a> (const KEY &amp;key, const VALUE &amp;val, FUNC func)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that key <code>key</code> exists in list, changes data of existing item to <code>data</code>. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename FUNC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a61ae06e3babd56943e84a58c6f5c238d">emplace</a> (const KEY &amp;key, const T &amp;val, FUNC func)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplaces the vale of key <code>key</code> with new value <code>val</code>.  <a href="#a61ae06e3babd56943e84a58c6f5c238d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VALUE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a6bf862c5fdc10bce89cfc43c28b030f6">get</a> (const KEY &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets value for the key.  <a href="#a6bf862c5fdc10bce89cfc43c28b030f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a350017d35170aac4905cf8c0d84ce656">find</a> (const KEY &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the key is in list.  <a href="#a350017d35170aac4905cf8c0d84ce656"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab502f8917ce7adfbe95152b9c6dfbefb"></a><!-- doxytag: member="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::empty" ref="ab502f8917ce7adfbe95152b9c6dfbefb" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#ab502f8917ce7adfbe95152b9c6dfbefb">empty</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if list is empty. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9cfa7c110b6b81a385f7fa5cf6db7df6"></a><!-- doxytag: member="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::clear" ref="a9cfa7c110b6b81a385f7fa5cf6db7df6" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a9cfa7c110b6b81a385f7fa5cf6db7df6">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the list. Not thread safe!!! <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a7aeda4b2f6134902c003947371397a5c">nonconcurrent_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a8ffa368e594731447388ebf334470720">nc_begin</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-concurrent forward start iterator.  <a href="#a8ffa368e594731447388ebf334470720"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a7aeda4b2f6134902c003947371397a5c">nonconcurrent_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a109ec0bf4cb8a260c86e44b359e7b7a9">nc_end</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-concurrent forward end iterator.  <a href="#a109ec0bf4cb8a260c86e44b359e7b7a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#aab9c849ce3405387e62bd2bbccc008b1">nonconcurrent_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#ac2c8749e64cd189ac2fe87ea906336d2">nc_begin</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-concurrent const forward start iterator.  <a href="#ac2c8749e64cd189ac2fe87ea906336d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#aab9c849ce3405387e62bd2bbccc008b1">nonconcurrent_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#acf1ebaea6ee92f298abfb4bb16d771ff">nc_end</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-concurrent const forward end iterator.  <a href="#acf1ebaea6ee92f298abfb4bb16d771ff"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01acb1caa7d5d960f19b58b904d58695"></a><!-- doxytag: member="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::allocNode" ref="a01acb1caa7d5d960f19b58b904d58695" args="(const KEY &amp;key)" -->
<a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a9d1b5dea05bd49a8444bdfaebcfbefec">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a01acb1caa7d5d960f19b58b904d58695">allocNode</a> (const KEY &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates node with <code>key</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10900531d7436ad980230c5bc8cd7d37"></a><!-- doxytag: member="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::allocNode" ref="a10900531d7436ad980230c5bc8cd7d37" args="(const KEY &amp;key, const VALUE &amp;data)" -->
<a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a9d1b5dea05bd49a8444bdfaebcfbefec">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a10900531d7436ad980230c5bc8cd7d37">allocNode</a> (const KEY &amp;key, const VALUE &amp;data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates new node with <code>key</code> and <code>data</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0ffdc821d7c074ca5c656eb7ab15a3e"></a><!-- doxytag: member="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::freeNode" ref="ae0ffdc821d7c074ca5c656eb7ab15a3e" args="(Node *pEntry)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#ae0ffdc821d7c074ca5c656eb7ab15a3e">freeNode</a> (<a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a9d1b5dea05bd49a8444bdfaebcfbefec">Node</a> *pEntry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the node <code>pEntry</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa585e1c41ee184e419e519dd63dcec7c"></a><!-- doxytag: member="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::getHead" ref="aa585e1c41ee184e419e519dd63dcec7c" args="()" -->
<a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a9d1b5dea05bd49a8444bdfaebcfbefec">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#aa585e1c41ee184e419e519dd63dcec7c">getHead</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the reference to list head. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc73656801e94395fe94e51df8597583"></a><!-- doxytag: member="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::insert" ref="acc73656801e94395fe94e51df8597583" args="(Node *pHead, const KEY &amp;key, const VALUE &amp;val)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#acc73656801e94395fe94e51df8597583">insert</a> (<a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a9d1b5dea05bd49a8444bdfaebcfbefec">Node</a> *pHead, const KEY &amp;key, const VALUE &amp;val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node &lt;<code>key</code>, <code>val&gt;</code> to sublist starting with <code>refHead</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f5d5c4e467d6686c50eb35eada189a3"></a><!-- doxytag: member="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::insert" ref="a1f5d5c4e467d6686c50eb35eada189a3" args="(Node *pNode)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a1f5d5c4e467d6686c50eb35eada189a3">insert</a> (<a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a9d1b5dea05bd49a8444bdfaebcfbefec">Node</a> *pNode)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts node <code>pNode</code> into the list. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc0cbbd2a2fcd1badc982af096fe19ce"></a><!-- doxytag: member="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::insert" ref="abc0cbbd2a2fcd1badc982af096fe19ce" args="(Node *pHead, Node *pNew)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#abc0cbbd2a2fcd1badc982af096fe19ce">insert</a> (<a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a9d1b5dea05bd49a8444bdfaebcfbefec">Node</a> *pHead, <a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a9d1b5dea05bd49a8444bdfaebcfbefec">Node</a> *pNew)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node <code>pNew</code> into the list starting with node <code>pHead</code>. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ad22a49a590ad0951c9b8d096f4d9c0c0"></a><!-- doxytag: member="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::emplace" ref="ad22a49a590ad0951c9b8d096f4d9c0c0" args="(Node *pHead, const KEY &amp;key, const T &amp;val, FUNC func)" -->
template&lt;typename T , typename FUNC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#ad22a49a590ad0951c9b8d096f4d9c0c0">emplace</a> (<a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a9d1b5dea05bd49a8444bdfaebcfbefec">Node</a> *pHead, const KEY &amp;key, const T &amp;val, FUNC func)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the value of its part for the list item pointed by <code>key</code>. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a9589b0d8040ee3fa965b4dcd0ab2e1b5"></a><!-- doxytag: member="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::ensure" ref="a9589b0d8040ee3fa965b4dcd0ab2e1b5" args="(Node *pHead, const KEY &amp;key, const VALUE &amp;val, FUNC func)" -->
template&lt;typename FUNC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a9589b0d8040ee3fa965b4dcd0ab2e1b5">ensure</a> (<a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a9d1b5dea05bd49a8444bdfaebcfbefec">Node</a> *pHead, const KEY &amp;key, const VALUE &amp;val, FUNC func)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that key <code>key</code> exists in sublist starting with <code>refHead</code>, changes data of existing item to <code>val</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c5f2772bed3d541f23d64b6a88fe21a"></a><!-- doxytag: member="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::find" ref="a8c5f2772bed3d541f23d64b6a88fe21a" args="(Node *pHead, const KEY &amp;key)" -->
VALUE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a8c5f2772bed3d541f23d64b6a88fe21a">find</a> (<a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a9d1b5dea05bd49a8444bdfaebcfbefec">Node</a> *pHead, const KEY &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> in list starting with node <code>pHead</code>. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56c3de084437d3043d47444c0f9cd4a3"></a><!-- doxytag: member="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::m_Head" ref="a56c3de084437d3043d47444c0f9cd4a3" args="" -->
<a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a9d1b5dea05bd49a8444bdfaebcfbefec">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a56c3de084437d3043d47444c0f9cd4a3">m_Head</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">List head (dummy node) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98a8de0bc82b135b6514ee768ba98dfa"></a><!-- doxytag: member="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::m_Tail" ref="a98a8de0bc82b135b6514ee768ba98dfa" args="" -->
<a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a9d1b5dea05bd49a8444bdfaebcfbefec">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a98a8de0bc82b135b6514ee768ba98dfa">m_Tail</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">List tail (dummy node) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa29ee02465df8d451d5b38d80010baa9"></a><!-- doxytag: member="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::m_Cmp" ref="aa29ee02465df8d451d5b38d80010baa9" args="" -->
<a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a146cc389a228e6b90c442f446d6b2f90">key_comparator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#aa29ee02465df8d451d5b38d80010baa9">m_Cmp</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Key comparator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8331aa2069d867f1d479e2610889311d"></a><!-- doxytag: member="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::m_Allocator" ref="a8331aa2069d867f1d479e2610889311d" args="" -->
<a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a2c828e5c5008bcf131b929ca60fbcae0">node_allocator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a8331aa2069d867f1d479e2610889311d">m_Allocator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Node allocator. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3edd1e40cc816f28f3944039bab0730c"></a><!-- doxytag: member="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::search" ref="a3edd1e40cc816f28f3944039bab0730c" args="(const Node *pHead, const KEY &amp;key) const " -->
Position&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a3edd1e40cc816f28f3944039bab0730c">search</a> (const <a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a9d1b5dea05bd49a8444bdfaebcfbefec">Node</a> *pHead, const KEY &amp;key) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches and returns insertion point for <code>key</code> starting with node <code>pHead</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbb03a267a5767a2de4a570f026c7d64"></a><!-- doxytag: member="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::validate" ref="abbb03a267a5767a2de4a570f026c7d64" args="(const Position &amp;pos) const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#abbb03a267a5767a2de4a570f026c7d64">validate</a> (const Position &amp;pos) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if position <code>pos</code> is valid (all position nodes is not marked) <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename KEY, typename VALUE, typename PAIR_TRAITS, typename TRAITS, class ALLOCATOR&gt;<br/>
 class cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;</h3>

<p>Persistent (no item deletion) lazy list specialization. </p>
<dl class="user"><dt><b>Template parameters</b></dt><dd><ul>
<li><code>KEY</code> type of key stored in list </li>
<li><code>VALUE</code> type of value stored in list </li>
<li><code>PAIR_TRAITS</code> (key, value) pair traits. The default is <a class="el" href="structcds_1_1map_1_1pair__traits.html" title="Pair (key, value) traits.">cds::map::pair_traits</a> &lt;<code>KEY</code>, <code>VALUE&gt;</code> </li>
<li><code>TRAITS</code> list traits. The default is <a class="el" href="structcds_1_1ordered__list_1_1type__traits.html" title="Ordered list default type traits class.">cds::ordered_list::type_traits</a> </li>
<li><code>ALLOCATOR</code> node allocator. The default is <code>std::allocator</code>.</li>
</ul>
</dd></dl>
<dl class="user"><dt><b>Source</b></dt><dd>[2005] Steve Heller, Maurice Herlihy, Victor Luchangco, Mark Moir, William N. Scherer III, and Nir Shavit "A Lazy Concurrent List-Based Set Algorithm"</dd></dl>
<dl class="user"><dt><b></b></dt><dd>Common interface: see <a class="el" href="ordered_list_common_interface.html">Ordered list common interface</a>. </dd></dl>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="aab9c849ce3405387e62bd2bbccc008b1"></a><!-- doxytag: member="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::nonconcurrent_const_iterator" ref="aab9c849ce3405387e62bd2bbccc008b1" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef NonConcurrentIterator&lt; const <a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#aad8e9ad748203372e9811b4165648a3a">value_type</a>&amp; &gt; cds::ordered_list::LazyList&lt; <a class="el" href="structcds_1_1gc_1_1no__gc.html">gc::no_gc</a>, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::<a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#aab9c849ce3405387e62bd2bbccc008b1">nonconcurrent_const_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Non-concurrent iterator. </p>
<p>This iterator is not thread-safe. В процессе обхода упорядоченного списка с помощью данного итератора не допускается удаление элементов из списка, так как удаление элемента, на который указывает итератор, может привести к обращению по удаленному указателю. </p>

</div>
</div>
<a class="anchor" id="a7aeda4b2f6134902c003947371397a5c"></a><!-- doxytag: member="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::nonconcurrent_iterator" ref="a7aeda4b2f6134902c003947371397a5c" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef NonConcurrentIterator&lt; <a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#aad8e9ad748203372e9811b4165648a3a">value_type</a>&amp; &gt; cds::ordered_list::LazyList&lt; <a class="el" href="structcds_1_1gc_1_1no__gc.html">gc::no_gc</a>, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::<a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a7aeda4b2f6134902c003947371397a5c">nonconcurrent_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Non-concurrent iterator. </p>
<p>This iterator is not thread-safe. В процессе обхода упорядоченного списка с помощью данного итератора не допускается удаление элементов из списка, так как удаление элемента, на который указывает итератор, может привести к обращению по удаленному указателю. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a61ae06e3babd56943e84a58c6f5c238d"></a><!-- doxytag: member="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::emplace" ref="a61ae06e3babd56943e84a58c6f5c238d" args="(const KEY &amp;key, const T &amp;val, FUNC func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename FUNC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cds::ordered_list::LazyList&lt; <a class="el" href="structcds_1_1gc_1_1no__gc.html">gc::no_gc</a>, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">const KEY &amp;&#160;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNC&#160;</td>
          <td class="paramname"> <em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Emplaces the vale of key <code>key</code> with new value <code>val</code>. </p>
<p>The operation changes the value (or a part of the value) of key <code>key</code> to new one <code>val</code>. The user-defined functor <code>func</code> has the purpose like <code>func</code> argument of <a class="el" href="ordered_list_common_interface.html#ensure">ensure</a> member function. The signature of <code>func</code> is </p>
<div class="fragment"><pre class="fragment">                <span class="keywordtype">void</span> func( VALUE&amp; itemValue, <span class="keyword">const</span> T&amp; val ) ;
</pre></div><p> The first argument <code>itemValue</code> of user-defined function <code>func</code> is the reference to the list's item pointed by key <code>key</code>. The second argument <code>val</code> is the value passed to <code>emplace</code> member function. User-defined function <code>func</code> must guarantee that during changing key's value no any other changes could be made on this list's item by concurrent threads. The list only garantees that the item found by key cannot be deleted while <code>func</code> worked</p>
<p>The function returns <code>true</code> if the key <code>key</code> exists in the list. </p>

</div>
</div>
<a class="anchor" id="a350017d35170aac4905cf8c0d84ce656"></a><!-- doxytag: member="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::find" ref="a350017d35170aac4905cf8c0d84ce656" args="(const KEY &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cds::ordered_list::LazyList&lt; <a class="el" href="structcds_1_1gc_1_1no__gc.html">gc::no_gc</a>, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const KEY &amp;&#160;</td>
          <td class="paramname"> <em>key</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks if the key is in list. </p>
<p>Returns <code>true</code> if the list contains <code>key</code> in list and <code>false</code> otherwise </p>

</div>
</div>
<a class="anchor" id="a6bf862c5fdc10bce89cfc43c28b030f6"></a><!-- doxytag: member="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::get" ref="a6bf862c5fdc10bce89cfc43c28b030f6" args="(const KEY &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VALUE* cds::ordered_list::LazyList&lt; <a class="el" href="structcds_1_1gc_1_1no__gc.html">gc::no_gc</a>, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const KEY &amp;&#160;</td>
          <td class="paramname"> <em>key</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets value for the key. </p>
<p>Returns pointer to value for <code>key</code> in list, <code>NULL</code> if the list does not contain <code>key</code> </p>

</div>
</div>
<a class="anchor" id="a926f3730aafbea2eb5c50712fc4517c4"></a><!-- doxytag: member="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::insert" ref="a926f3730aafbea2eb5c50712fc4517c4" args="(const KEY &amp;key, const VALUE &amp;data)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cds::ordered_list::LazyList&lt; <a class="el" href="structcds_1_1gc_1_1no__gc.html">gc::no_gc</a>, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const KEY &amp;&#160;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE &amp;&#160;</td>
          <td class="paramname"> <em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inserts new node. </p>
<p>Inserts new node &lt;<code>key</code>, <code>data&gt;</code> into the list. Returns <code>false</code> if key <code>key</code> already in list,<code>true</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a8ffa368e594731447388ebf334470720"></a><!-- doxytag: member="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::nc_begin" ref="a8ffa368e594731447388ebf334470720" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a7aeda4b2f6134902c003947371397a5c">nonconcurrent_iterator</a> cds::ordered_list::LazyList&lt; <a class="el" href="structcds_1_1gc_1_1no__gc.html">gc::no_gc</a>, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::nc_begin </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns non-concurrent forward start iterator. </p>
<p>For an empty list start iterator is equal to <em>end()</em>. </p>

</div>
</div>
<a class="anchor" id="ac2c8749e64cd189ac2fe87ea906336d2"></a><!-- doxytag: member="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::nc_begin" ref="ac2c8749e64cd189ac2fe87ea906336d2" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#aab9c849ce3405387e62bd2bbccc008b1">nonconcurrent_const_iterator</a> cds::ordered_list::LazyList&lt; <a class="el" href="structcds_1_1gc_1_1no__gc.html">gc::no_gc</a>, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::nc_begin </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns non-concurrent const forward start iterator. </p>
<p>For an empty list start iterator is equal to <em>end()</em> В процессе обхода упорядоченного списка не допускается удаление его элементов. </p>

</div>
</div>
<a class="anchor" id="a109ec0bf4cb8a260c86e44b359e7b7a9"></a><!-- doxytag: member="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::nc_end" ref="a109ec0bf4cb8a260c86e44b359e7b7a9" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#a7aeda4b2f6134902c003947371397a5c">nonconcurrent_iterator</a> cds::ordered_list::LazyList&lt; <a class="el" href="structcds_1_1gc_1_1no__gc.html">gc::no_gc</a>, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::nc_end </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns non-concurrent forward end iterator. </p>
<p>End iterator points to tail dummy node. You may use end iterator for comparison only </p>

</div>
</div>
<a class="anchor" id="acf1ebaea6ee92f298abfb4bb16d771ff"></a><!-- doxytag: member="cds::ordered_list::LazyList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::nc_end" ref="acf1ebaea6ee92f298abfb4bb16d771ff" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1ordered__list_1_1_lazy_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_a_iaca93a45733c94d7f1478ca0a1f05451.html#aab9c849ce3405387e62bd2bbccc008b1">nonconcurrent_const_iterator</a> cds::ordered_list::LazyList&lt; <a class="el" href="structcds_1_1gc_1_1no__gc.html">gc::no_gc</a>, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::nc_end </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns non-concurrent const forward end iterator. </p>
<p>End iterator points to tail dummy node. You may use end iterator for comparison only </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/ordered_list/lazy_list_nogc.h</li>
</ul>
</div>
		<hr/>
		<div align="right">
			<b>cds</b> <b>0.7.0</b> 
			Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2010
			<br/>
			<i>Autogenerated Sun Dec 5 2010 11:36:36 by Doxygen 1.7.2</i>
		</div>
	</BODY>
</HTML>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cds: cds::ordered_list::MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacecds.html">cds</a>      </li>
      <li><a class="el" href="namespacecds_1_1ordered__list.html">ordered_list</a>      </li>
      <li><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html">MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<h1>cds::ordered_list::MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="cds::ordered_list::MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;" --><!-- doxytag: inherits="cds::ordered_list::OrderedList,michael_list_tag&lt; gc::no_gc &gt;" -->
<p>Persistent (no deletion) Michael's ordered list.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;michael_list_nogc.h&gt;</code></p>
<!-- startSectionHeader --><div class="dynheader">
Inheritance diagram for cds::ordered_list::MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;:<!-- endSectionHeader --></div>
<!-- startSectionSummary --><!-- endSectionSummary --><!-- startSectionContent --><div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.png" usemap="#cds::ordered_list::MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;_map" alt=""/>
  <map id="cds::ordered_list::MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;_map" name="cds::ordered_list::MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;_map">
<area href="structcds_1_1ordered__list_1_1_ordered_list.html" alt="cds::ordered_list::OrderedList&lt; KEY, VALUE, TRAITS &gt;" shape="rect" coords="0,56,560,80"/>
<area href="structcds_1_1ordered__list_1_1michael__list__tag.html" alt="cds::ordered_list::michael_list_tag&lt; gc::no_gc &gt;" shape="rect" coords="570,56,1130,80"/>
<area href="structcds_1_1ordered__list_1_1ordered__list__tag.html" alt="cds::ordered_list::ordered_list_tag" shape="rect" coords="0,0,560,24"/>
</map>
 </div><!-- endSectionContent --></div>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_c632c02f297438a45373a97f8c1750fe.html">NonConcurrentIterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-concurrent iterator.  <a href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_c632c02f297438a45373a97f8c1750fe.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p32deab6d69d69403194256e5bdb3c003.html">rebind</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebind type of key-value pair stored in the list.  <a href="structcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p32deab6d69d69403194256e5bdb3c003.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p7184a9ccda001877668cc8aca1908d25.html">type_traits</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">List type traits.  <a href="structcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p7184a9ccda001877668cc8aca1908d25.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf9ae37f3476a16c48fe683a9d80b045"></a><!-- doxytag: member="cds::ordered_list::MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::gc_schema" ref="aaf9ae37f3476a16c48fe683a9d80b045" args="" -->
typedef <a class="el" href="structcds_1_1gc_1_1no__gc.html">gc::no_gc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#aaf9ae37f3476a16c48fe683a9d80b045">gc_schema</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collection schema. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50d1b190bb4c5bdfe5df63c4c99a87a8"></a><!-- doxytag: member="cds::ordered_list::MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::key_type" ref="a50d1b190bb4c5bdfe5df63c4c99a87a8" args="" -->
typedef base_class::key_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#a50d1b190bb4c5bdfe5df63c4c99a87a8">key_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Key type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fe67e80aec15b9951b802762cccb0c9"></a><!-- doxytag: member="cds::ordered_list::MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::value_type" ref="a2fe67e80aec15b9951b802762cccb0c9" args="" -->
typedef base_class::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#a2fe67e80aec15b9951b802762cccb0c9">value_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a369c8a53bc4c651a520a14385b1899eb"></a><!-- doxytag: member="cds::ordered_list::MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::pair_traits" ref="a369c8a53bc4c651a520a14385b1899eb" args="" -->
typedef PAIR_TRAITS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#a369c8a53bc4c651a520a14385b1899eb">pair_traits</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pair traits type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e3eebbc881eb310aa7617e3135b9f52"></a><!-- doxytag: member="cds::ordered_list::MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::key_traits" ref="a0e3eebbc881eb310aa7617e3135b9f52" args="" -->
typedef pair_traits::key_traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#a0e3eebbc881eb310aa7617e3135b9f52">key_traits</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Key traits. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a723519ce0634a56960fd8e2fc40fb766"></a><!-- doxytag: member="cds::ordered_list::MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::value_traits" ref="a723519ce0634a56960fd8e2fc40fb766" args="" -->
typedef pair_traits::value_traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#a723519ce0634a56960fd8e2fc40fb766">value_traits</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Value traits. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb8341035cd92cd9e7cfae2127fe30af"></a><!-- doxytag: member="cds::ordered_list::MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::key_comparator" ref="abb8341035cd92cd9e7cfae2127fe30af" args="" -->
typedef key_traits::key_comparator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#abb8341035cd92cd9e7cfae2127fe30af">key_comparator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Key comparator (binary predicate) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa99d68066ff2c7ee203982e1fc867f54"></a><!-- doxytag: member="cds::ordered_list::MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::Node" ref="aa99d68066ff2c7ee203982e1fc867f54" args="" -->
typedef <br class="typebreak"/>
details::michael_list::Node<br class="typebreak"/>
&lt; <a class="el" href="structcds_1_1gc_1_1no__gc.html">gc_schema</a>, <a class="el" href="structcds_1_1ordered__list_1_1_ordered_list.html#af1afde5667bafa0d455cfce25782d9e4">key_type</a>, <br class="typebreak"/>
<a class="el" href="structcds_1_1ordered__list_1_1_ordered_list.html#a645a6ea2909d55fe856b360032434280">value_type</a>, ALLOCATOR &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#aa99d68066ff2c7ee203982e1fc867f54">Node</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">internal node <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc9ba02ff0991deb7114a112b580705b"></a><!-- doxytag: member="cds::ordered_list::MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::node_allocator" ref="adc9ba02ff0991deb7114a112b580705b" args="" -->
typedef Node::node_allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#adc9ba02ff0991deb7114a112b580705b">node_allocator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">node allocator <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef NonConcurrentIterator<br class="typebreak"/>
&lt; <a class="el" href="structcds_1_1ordered__list_1_1_ordered_list.html#a645a6ea2909d55fe856b360032434280">value_type</a> &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#aa1ecfd29a4233a192aa786ef2ec9fc19">nonconcurrent_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-concurrent iterator.  <a href="#aa1ecfd29a4233a192aa786ef2ec9fc19"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef NonConcurrentIterator<br class="typebreak"/>
&lt; const <a class="el" href="structcds_1_1ordered__list_1_1_ordered_list.html#a645a6ea2909d55fe856b360032434280">value_type</a> &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#ab0fc50e77be6a4085470834e429c2bff">nonconcurrent_const_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-concurrent iterator.  <a href="#ab0fc50e77be6a4085470834e429c2bff"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a7e33792c4450b630f173a3f5b35cf5"></a><!-- doxytag: member="cds::ordered_list::MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::MichaelList" ref="a6a7e33792c4450b630f173a3f5b35cf5" args="()" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#a6a7e33792c4450b630f173a3f5b35cf5">MichaelList</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create empty list. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#aa7cda397a0359f49f6312931a64f9ffd">insert</a> (const KEY &amp;key, const VALUE &amp;val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#aa7cda397a0359f49f6312931a64f9ffd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bcc4f6887a6499b96793916a8f13b24"></a><!-- doxytag: member="cds::ordered_list::MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::insert" ref="a3bcc4f6887a6499b96793916a8f13b24" args="(const KEY &amp;key)" -->
VALUE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#a3bcc4f6887a6499b96793916a8f13b24">insert</a> (const KEY &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node. If <code>key</code> exists returns NULL, else returns pointer to the value field of inserted item. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename FUNC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#af63a0accab2ed0c17518d457e73dc7a3">ensure</a> (const KEY &amp;key, const VALUE &amp;val, FUNC func)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that key <code>key</code> exists in list, changes data of existing item to <code>data</code>.  <a href="#af63a0accab2ed0c17518d457e73dc7a3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename FUNC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#a6a760a508bba722ce023c1e59f9b3978">emplace</a> (const KEY &amp;key, const T &amp;val, FUNC func)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplaces the vale of key <code>key</code> with new value <code>val</code>.  <a href="#a6a760a508bba722ce023c1e59f9b3978"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VALUE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#ab9c76306fb6870c47dbfd4dca196b5bc">get</a> (const KEY &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets value for the key.  <a href="#ab9c76306fb6870c47dbfd4dca196b5bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48dbbf2e057c112fbc18e938dbf884e2"></a><!-- doxytag: member="cds::ordered_list::MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::find" ref="a48dbbf2e057c112fbc18e938dbf884e2" args="(const KEY &amp;key)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#a48dbbf2e057c112fbc18e938dbf884e2">find</a> (const KEY &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds node by <code>key</code>. Returns false if <code>key</code> is not in the list. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a2d5130561089a604358f72fccdb8fe"></a><!-- doxytag: member="cds::ordered_list::MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::empty" ref="a7a2d5130561089a604358f72fccdb8fe" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#a7a2d5130561089a604358f72fccdb8fe">empty</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if list is empty. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c500923711c308ee7a2f5526aaab9b7"></a><!-- doxytag: member="cds::ordered_list::MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::clear" ref="a9c500923711c308ee7a2f5526aaab9b7" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#a9c500923711c308ee7a2f5526aaab9b7">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the list. Not thread safe!!! <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#aa1ecfd29a4233a192aa786ef2ec9fc19">nonconcurrent_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#ad2c152c084097a07422dd5dafd1af017">nc_begin</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-concurrent forward start iterator.  <a href="#ad2c152c084097a07422dd5dafd1af017"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#aa1ecfd29a4233a192aa786ef2ec9fc19">nonconcurrent_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#abd01978706b299e9af9c17ac8908e47d">nc_end</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-concurrent forward end iterator.  <a href="#abd01978706b299e9af9c17ac8908e47d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#ab0fc50e77be6a4085470834e429c2bff">nonconcurrent_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#ac0f42fa24a44b9a2d048dcfb8f8b14f9">nc_begin</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-concurrent const forward start iterator.  <a href="#ac0f42fa24a44b9a2d048dcfb8f8b14f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#ab0fc50e77be6a4085470834e429c2bff">nonconcurrent_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#aa701a9f50a353c714c4abcc3aaa194e4">nc_end</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-concurrent const forward end iterator.  <a href="#aa701a9f50a353c714c4abcc3aaa194e4"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d1985591624841b98d43b45c24e19b7"></a><!-- doxytag: member="cds::ordered_list::MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::m_pHead" ref="a3d1985591624841b98d43b45c24e19b7" args="" -->
<a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#aa99d68066ff2c7ee203982e1fc867f54">Node</a> *volatile&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#a3d1985591624841b98d43b45c24e19b7">m_pHead</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">List head node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae36a16a7cbd05dad4d89f271fb86c179"></a><!-- doxytag: member="cds::ordered_list::MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::m_Cmp" ref="ae36a16a7cbd05dad4d89f271fb86c179" args="" -->
<a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#abb8341035cd92cd9e7cfae2127fe30af">key_comparator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#ae36a16a7cbd05dad4d89f271fb86c179">m_Cmp</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Key comparator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f075957b05f7656b31c21736e76ca17"></a><!-- doxytag: member="cds::ordered_list::MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::m_Allocator" ref="a0f075957b05f7656b31c21736e76ca17" args="" -->
<a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#adc9ba02ff0991deb7114a112b580705b">node_allocator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#a0f075957b05f7656b31c21736e76ca17">m_Allocator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Node allocator. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename KEY, typename VALUE, typename PAIR_TRAITS, typename TRAITS, class ALLOCATOR&gt;<br/>
 class cds::ordered_list::MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;</h3>

<p>Persistent (no deletion) Michael's ordered list. </p>
<p>Implementation of Michael's ordered list with no garbage collection</p>
<dl class="user"><dt><b>Template parameters</b></dt><dd><ul>
<li><code>KEY</code> type of key stored in list </li>
<li><code>VALUE</code> type of value stored in list </li>
<li><code>PAIR_TRAITS</code> (key, value) pair traits. The default is <a class="el" href="structcds_1_1map_1_1pair__traits.html" title="Pair (key, value) traits.">cds::map::pair_traits</a> &lt;<code>KEY</code>, <code>VALUE&gt;</code> </li>
<li><code>TRAITS</code> list traits. The default is <a class="el" href="structcds_1_1ordered__list_1_1type__traits.html" title="Ordered list default type traits class.">cds::ordered_list::type_traits</a> </li>
<li><code>ALLOCATOR</code> node allocator. The default is std::allocator.</li>
</ul>
This is a specialization of <em>MichaelList</em> class. Deletion of item is not supported.</dd></dl>
<dl class="user"><dt><b>Source</b></dt><dd>[2002] Maged Michael "High performance dynamic lock-free hash tables and list-based sets"</dd></dl>
<dl class="user"><dt><b></b></dt><dd>Common interface: see <a class="el" href="ordered_list_common_interface.html">Ordered list common interface</a>. </dd></dl>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="ab0fc50e77be6a4085470834e429c2bff"></a><!-- doxytag: member="cds::ordered_list::MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::nonconcurrent_const_iterator" ref="ab0fc50e77be6a4085470834e429c2bff" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef NonConcurrentIterator&lt; const <a class="el" href="structcds_1_1ordered__list_1_1_ordered_list.html#a645a6ea2909d55fe856b360032434280">value_type</a>&amp; &gt; cds::ordered_list::MichaelList&lt; <a class="el" href="structcds_1_1gc_1_1no__gc.html">gc::no_gc</a>, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::<a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#ab0fc50e77be6a4085470834e429c2bff">nonconcurrent_const_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Non-concurrent iterator. </p>
<p>This iterator is not thread-safe. </p>

</div>
</div>
<a class="anchor" id="aa1ecfd29a4233a192aa786ef2ec9fc19"></a><!-- doxytag: member="cds::ordered_list::MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::nonconcurrent_iterator" ref="aa1ecfd29a4233a192aa786ef2ec9fc19" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef NonConcurrentIterator&lt; <a class="el" href="structcds_1_1ordered__list_1_1_ordered_list.html#a645a6ea2909d55fe856b360032434280">value_type</a>&amp; &gt; cds::ordered_list::MichaelList&lt; <a class="el" href="structcds_1_1gc_1_1no__gc.html">gc::no_gc</a>, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::<a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#aa1ecfd29a4233a192aa786ef2ec9fc19">nonconcurrent_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Non-concurrent iterator. </p>
<p>This iterator is not thread-safe. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a6a760a508bba722ce023c1e59f9b3978"></a><!-- doxytag: member="cds::ordered_list::MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::emplace" ref="a6a760a508bba722ce023c1e59f9b3978" args="(const KEY &amp;key, const T &amp;val, FUNC func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename FUNC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cds::ordered_list::MichaelList&lt; <a class="el" href="structcds_1_1gc_1_1no__gc.html">gc::no_gc</a>, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">const KEY &amp;&#160;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNC&#160;</td>
          <td class="paramname"> <em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Emplaces the vale of key <code>key</code> with new value <code>val</code>. </p>
<p>The operation changes the value (or a part of the value) of key <code>key</code> to new one <code>val</code>. The user-defined functor <code>func</code> has the purpose like <code>func</code> argument of <a class="el" href="ordered_list_common_interface.html#ensure">ensure</a> member function. The signature of <code>func</code> is </p>
<div class="fragment"><pre class="fragment">                <span class="keywordtype">void</span> func( VALUE&amp; itemValue, <span class="keyword">const</span> T&amp; val ) ;
</pre></div><p> The first argument <code>itemValue</code> of user-defined function <code>func</code> is the reference to the list's item pointed by key <code>key</code>. The second argument <code>val</code> is the value passed to <code>emplace</code> member function. User-defined function <code>func</code> must guarantee that during changing key's value no any other changes could be made on this list's item by concurrent threads. The list only garantees that the item found by key cannot be deleted while <code>func</code> worked</p>
<p>The function returns <code>true</code> if the key <code>key</code> exists in the list. </p>

</div>
</div>
<a class="anchor" id="af63a0accab2ed0c17518d457e73dc7a3"></a><!-- doxytag: member="cds::ordered_list::MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::ensure" ref="af63a0accab2ed0c17518d457e73dc7a3" args="(const KEY &amp;key, const VALUE &amp;val, FUNC func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR &gt; </div>
<div class="memtemplate">
template&lt;typename FUNC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, bool&gt; cds::ordered_list::MichaelList&lt; <a class="el" href="structcds_1_1gc_1_1no__gc.html">gc::no_gc</a>, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::ensure </td>
          <td>(</td>
          <td class="paramtype">const KEY &amp;&#160;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE &amp;&#160;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNC&#160;</td>
          <td class="paramname"> <em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ensures that key <code>key</code> exists in list, changes data of existing item to <code>data</code>. </p>
<p>The operation performs insert or change data with lock-free manner.</p>
<p>If <code>key</code> is in the list then changes its value to <code>val</code> If <code>key</code> is not in list then add it. Returns std::pair&lt;bool, bool&gt; where <code>first</code> is true if operation is successfull, <code>second</code> is true if new item has been added or <code>false</code> if the item with <code>key</code> already in list. </p>

</div>
</div>
<a class="anchor" id="ab9c76306fb6870c47dbfd4dca196b5bc"></a><!-- doxytag: member="cds::ordered_list::MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::get" ref="ab9c76306fb6870c47dbfd4dca196b5bc" args="(const KEY &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VALUE* cds::ordered_list::MichaelList&lt; <a class="el" href="structcds_1_1gc_1_1no__gc.html">gc::no_gc</a>, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const KEY &amp;&#160;</td>
          <td class="paramname"> <em>key</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets value for the key. </p>
<p>Returns pointer to value for <code>key</code> in list, <code>NULL</code> if the list does not contain <code>key</code> </p>

</div>
</div>
<a class="anchor" id="aa7cda397a0359f49f6312931a64f9ffd"></a><!-- doxytag: member="cds::ordered_list::MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::insert" ref="aa7cda397a0359f49f6312931a64f9ffd" args="(const KEY &amp;key, const VALUE &amp;val)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cds::ordered_list::MichaelList&lt; <a class="el" href="structcds_1_1gc_1_1no__gc.html">gc::no_gc</a>, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const KEY &amp;&#160;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE &amp;&#160;</td>
          <td class="paramname"> <em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inserts new node. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Node's key </td></tr>
    <tr><td class="paramname">val</td><td>Node's value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac0f42fa24a44b9a2d048dcfb8f8b14f9"></a><!-- doxytag: member="cds::ordered_list::MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::nc_begin" ref="ac0f42fa24a44b9a2d048dcfb8f8b14f9" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#ab0fc50e77be6a4085470834e429c2bff">nonconcurrent_const_iterator</a> cds::ordered_list::MichaelList&lt; <a class="el" href="structcds_1_1gc_1_1no__gc.html">gc::no_gc</a>, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::nc_begin </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns non-concurrent const forward start iterator. </p>
<p>For an empty list start iterator is equal to <em>end()</em> </p>

</div>
</div>
<a class="anchor" id="ad2c152c084097a07422dd5dafd1af017"></a><!-- doxytag: member="cds::ordered_list::MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::nc_begin" ref="ad2c152c084097a07422dd5dafd1af017" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#aa1ecfd29a4233a192aa786ef2ec9fc19">nonconcurrent_iterator</a> cds::ordered_list::MichaelList&lt; <a class="el" href="structcds_1_1gc_1_1no__gc.html">gc::no_gc</a>, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::nc_begin </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns non-concurrent forward start iterator. </p>
<p>For an empty list start iterator is equal to <em>end()</em>. </p>

</div>
</div>
<a class="anchor" id="aa701a9f50a353c714c4abcc3aaa194e4"></a><!-- doxytag: member="cds::ordered_list::MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::nc_end" ref="aa701a9f50a353c714c4abcc3aaa194e4" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#ab0fc50e77be6a4085470834e429c2bff">nonconcurrent_const_iterator</a> cds::ordered_list::MichaelList&lt; <a class="el" href="structcds_1_1gc_1_1no__gc.html">gc::no_gc</a>, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::nc_end </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns non-concurrent const forward end iterator. </p>
<p>End iterator is simple NULL. You may use end iterator for comparison only </p>

</div>
</div>
<a class="anchor" id="abd01978706b299e9af9c17ac8908e47d"></a><!-- doxytag: member="cds::ordered_list::MichaelList&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::nc_end" ref="abd01978706b299e9af9c17ac8908e47d" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1ordered__list_1_1_michael_list_3_01gc_1_1no__gc_00_01_k_e_y_00_01_v_a_l_u_e_00_01_p_b3efa5e5b1c65157da88fce6ea4b5e02.html#aa1ecfd29a4233a192aa786ef2ec9fc19">nonconcurrent_iterator</a> cds::ordered_list::MichaelList&lt; <a class="el" href="structcds_1_1gc_1_1no__gc.html">gc::no_gc</a>, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::nc_end </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns non-concurrent forward end iterator. </p>
<p>End iterator is simple NULL. You may use end iterator for comparison only </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/ordered_list/michael_list_nogc.h</li>
</ul>
</div>
		<hr/>
		<div align="right">
			<b>cds</b> <b>0.7.0</b> 
			Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2010
			<br/>
			<i>Autogenerated Sun Dec 5 2010 11:36:37 by Doxygen 1.7.2</i>
		</div>
	</BODY>
</HTML>

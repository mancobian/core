<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cds: cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacecds.html">cds</a>      </li>
      <li><a class="el" href="namespacecds_1_1queue.html">queue</a>      </li>
      <li><a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html">MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-types">Private Types</a>  </div>
  <div class="headertitle">
<h1>cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;" --><!-- doxytag: inherits="cds::gc::hrc::Container" -->
<p>Michael &amp; Scott lock-free queue implementation based on Gidenstam's memory reclamation schema (HRC)  
<a href="#_details">More...</a></p>

<p><code>#include &lt;msqueue_hrc.h&gt;</code></p>
<!-- startSectionHeader --><div class="dynheader">
Inheritance diagram for cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;:<!-- endSectionHeader --></div>
<!-- startSectionSummary --><!-- endSectionSummary --><!-- startSectionContent --><div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.png" usemap="#cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;_map" alt=""/>
  <map id="cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;_map" name="cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;_map">
<area href="classcds_1_1gc_1_1hrc_1_1_container.html" alt="cds::gc::hrc::Container" shape="rect" coords="0,0,378,24"/>
<area href="classcds_1_1queue_1_1_moir_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html" alt="cds::queue::MoirQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;" shape="rect" coords="0,112,378,136"/>
</map>
 </div><!-- endSectionContent --></div>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4_1_1_node.html">Node</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue node.  <a href="structcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4_1_1_node.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_ad032c810027e074568b0da741bacd1c.html">NonConcurrentIterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-concurrent iterator class. Not thread-safe!!! For debugging only.  <a href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_ad032c810027e074568b0da741bacd1c.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab88b25963ebf616168d7692594dff211"></a><!-- doxytag: member="cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;::gc_schema" ref="ab88b25963ebf616168d7692594dff211" args="" -->
typedef <a class="el" href="structcds_1_1gc_1_1hrc__gc.html">gc::hrc_gc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html#ab88b25963ebf616168d7692594dff211">gc_schema</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collection schema. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7c1b3ac0eb2ca14ddef6ed0ffe6f459"></a><!-- doxytag: member="cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;::type_traits" ref="af7c1b3ac0eb2ca14ddef6ed0ffe6f459" args="" -->
typedef normalized_type_traits<br class="typebreak"/>
&lt; TRAITS &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html#af7c1b3ac0eb2ca14ddef6ed0ffe6f459">type_traits</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue traits. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58ffe33d96f1a11648cabbfc3b63fece"></a><!-- doxytag: member="cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;::value_type" ref="a58ffe33d96f1a11648cabbfc3b63fece" args="" -->
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html#a58ffe33d96f1a11648cabbfc3b63fece">value_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of value saved in queue. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08c6285d1f4eefa42564ba8d2500845b"></a><!-- doxytag: member="cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;::nonconcurrent_iterator" ref="a08c6285d1f4eefa42564ba8d2500845b" args="" -->
typedef NonConcurrentIterator&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html#a08c6285d1f4eefa42564ba8d2500845b">nonconcurrent_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-concurrent iterator. Not thread-safe!!! <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff946db0bbb946b0c8d6a5c0bd13fdbf"></a><!-- doxytag: member="cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;::nonconcurrent_const_iterator" ref="aff946db0bbb946b0c8d6a5c0bd13fdbf" args="" -->
typedef NonConcurrentIterator<br class="typebreak"/>
&lt; const T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html#aff946db0bbb946b0c8d6a5c0bd13fdbf">nonconcurrent_const_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-concurrent const iterator. Not thread-safe!!! <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa67f4b0ed9892006be86efcc7773dd9"></a><!-- doxytag: member="cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;::MSQueue" ref="aaa67f4b0ed9892006be86efcc7773dd9" args="()" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html#aaa67f4b0ed9892006be86efcc7773dd9">MSQueue</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs empty queue. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4061298c513816483720ad57f70994b"></a><!-- doxytag: member="cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;::~MSQueue" ref="ad4061298c513816483720ad57f70994b" args="()" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html#ad4061298c513816483720ad57f70994b">~MSQueue</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears queue and destruct. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92d763d4df1e273f57a2fdfc50a5a575"></a><!-- doxytag: member="cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;::size" ref="a92d763d4df1e273f57a2fdfc50a5a575" args="() const " -->
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html#a92d763d4df1e273f57a2fdfc50a5a575">size</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of items in queue. Valid only if <code>TRAITS::item_counter_type</code> is not the <a class="el" href="classcds_1_1atomics_1_1empty__item__counter.html" title="Empty item counter.">cds::atomics::empty_item_counter</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad88deea801b8a23db56eeec48a576193"></a><!-- doxytag: member="cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;::getStatistics" ref="ad88deea801b8a23db56eeec48a576193" args="() const " -->
const type_traits::statistics &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html#ad88deea801b8a23db56eeec48a576193">getStatistics</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns internal statistics. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f6443b466430840e891b46de47861d6"></a><!-- doxytag: member="cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;::enqueue" ref="a9f6443b466430840e891b46de47861d6" args="(const T &amp;data)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html#a9f6443b466430840e891b46de47861d6">enqueue</a> (const T &amp;data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues <code>data</code> to queue. Always returns <em>true</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html#a587222570bd26d1edd6d8133ee4dd9ea">dequeue</a> (T &amp;dest)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1875114a21d91fd58886c31e5a02eb8b"></a><!-- doxytag: member="cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;::push" ref="a1875114a21d91fd58886c31e5a02eb8b" args="(const T &amp;data)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html#a1875114a21d91fd58886c31e5a02eb8b">push</a> (const T &amp;data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for <a class="el" href="queue_common_interface.html#enqueue">enqueue</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f75dcda420ef32063689bc2a380da4c"></a><!-- doxytag: member="cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;::pop" ref="a5f75dcda420ef32063689bc2a380da4c" args="(T &amp;data)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html#a5f75dcda420ef32063689bc2a380da4c">pop</a> (T &amp;data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for <a class="el" href="queue_common_interface.html#dequeue">dequeue</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7068b9a6833e0ffabe813452774b63fc"></a><!-- doxytag: member="cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;::empty" ref="a7068b9a6833e0ffabe813452774b63fc" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html#a7068b9a6833e0ffabe813452774b63fc">empty</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if queue is empty. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3cf7a2ac89af79f8d6ca40541528f45a"></a><!-- doxytag: member="cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;::clear" ref="a3cf7a2ac89af79f8d6ca40541528f45a" args="()" -->
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html#a3cf7a2ac89af79f8d6ca40541528f45a">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears queue in lock-free manner. Return the number of removed items. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2e95c985b292a5875ed46c602e9211a"></a><!-- doxytag: member="cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;::begin" ref="ab2e95c985b292a5875ed46c602e9211a" args="()" -->
<a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html#a08c6285d1f4eefa42564ba8d2500845b">nonconcurrent_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html#ab2e95c985b292a5875ed46c602e9211a">begin</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns start non-concurrent iterator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add8642c086fe0f95328d2562e163e7a7"></a><!-- doxytag: member="cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;::end" ref="add8642c086fe0f95328d2562e163e7a7" args="()" -->
<a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html#a08c6285d1f4eefa42564ba8d2500845b">nonconcurrent_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html#add8642c086fe0f95328d2562e163e7a7">end</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns end non-concurrent iterator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8340d4c6aa7b9d00a81d5d599921bf03"></a><!-- doxytag: member="cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;::begin" ref="a8340d4c6aa7b9d00a81d5d599921bf03" args="() const " -->
<a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html#aff946db0bbb946b0c8d6a5c0bd13fdbf">nonconcurrent_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html#a8340d4c6aa7b9d00a81d5d599921bf03">begin</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns start non-concurrent const iterator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c4066f332469a0f521236c5e45f2bfa"></a><!-- doxytag: member="cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;::end" ref="a6c4066f332469a0f521236c5e45f2bfa" args="() const " -->
<a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html#aff946db0bbb946b0c8d6a5c0bd13fdbf">nonconcurrent_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html#a6c4066f332469a0f521236c5e45f2bfa">end</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns end non-concurrent const iterator. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6bb7d3cb5ce582972bee166f0e19bfb4"></a><!-- doxytag: member="cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;::m_nHazardPointerCount" ref="a6bb7d3cb5ce582972bee166f0e19bfb4" args="" -->
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html#a6bb7d3cb5ce582972bee166f0e19bfb4">m_nHazardPointerCount</a> = 3</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum hazard pointer count required for queue algorithm. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcds_1_1gc_1_1hrc_1_1_thread_g_c.html">cds::gc::hrc::ThreadGC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html#ae9015fc6885a7176d46adc2161d94fcc">TThreadGC</a></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a895b10ba0905fcf4497282848a80a5dc"></a><!-- doxytag: member="cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;::allocNode" ref="a895b10ba0905fcf4497282848a80a5dc" args="()" -->
Node *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html#a895b10ba0905fcf4497282848a80a5dc">allocNode</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a573720ad320c563c95cfb7f21d374c5a"></a><!-- doxytag: member="cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;::allocNode" ref="a573720ad320c563c95cfb7f21d374c5a" args="(const T &amp;data)" -->
Node *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html#a573720ad320c563c95cfb7f21d374c5a">allocNode</a> (const T &amp;data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a node and initialize it. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a6043d94bf117f4f7edbf0f940d40a1"></a><!-- doxytag: member="cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;::getHeadRef" ref="a9a6043d94bf117f4f7edbf0f940d40a1" args="()" -->
Node *volatile &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html#a9a6043d94bf117f4f7edbf0f940d40a1">getHeadRef</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to head node. For VC and GCC compatibility. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa44108e23a917fe38ae53119f2275cc"></a><!-- doxytag: member="cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;::getTailRef" ref="aaa44108e23a917fe38ae53119f2275cc" args="()" -->
Node *volatile &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html#aaa44108e23a917fe38ae53119f2275cc">getTailRef</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to tail node. For VC and GCC compatibility. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeee8738d362a110ac4d82f68f818fe23"></a><!-- doxytag: member="cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;::m_pHead" ref="aeee8738d362a110ac4d82f68f818fe23" args="" -->
Node *volatile&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html#aeee8738d362a110ac4d82f68f818fe23">m_pHead</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue's head. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf0aae5aa921faf91c51cdca11b38ec1"></a><!-- doxytag: member="cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;::m_pTail" ref="acf0aae5aa921faf91c51cdca11b38ec1" args="" -->
Node *volatile&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html#acf0aae5aa921faf91c51cdca11b38ec1">m_pTail</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue's tail. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74b6f3750a0fa1f32cee8d34fff895aa"></a><!-- doxytag: member="cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;::m_ItemCounter" ref="a74b6f3750a0fa1f32cee8d34fff895aa" args="" -->
type_traits::item_counter_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html#a74b6f3750a0fa1f32cee8d34fff895aa">m_ItemCounter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5401f54b264f58ccb34f20b3b9463447"></a><!-- doxytag: member="cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;::m_Stat" ref="a5401f54b264f58ccb34f20b3b9463447" args="" -->
type_traits::statistics&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html#a5401f54b264f58ccb34f20b3b9463447">m_Stat</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal statistics. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac092531bb615dd99187aa12637c9071a"></a><!-- doxytag: member="cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;::base_class" ref="ac092531bb615dd99187aa12637c9071a" args="" -->
typedef <a class="el" href="classcds_1_1gc_1_1hrc_1_1_container.html">gc::hrc::Container</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html#ac092531bb615dd99187aa12637c9071a">base_class</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename T, class TRAITS, class ALLOCATOR&gt;<br/>
 class cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;</h3>

<p>Michael &amp; Scott lock-free queue implementation based on Gidenstam's memory reclamation schema (HRC) </p>
<dl class="user"><dt><b>Source:</b></dt><dd><ul>
<li>[2006] A.Gidenstam "Algorithms for synchronization and consistency
                        in concurrent system services", Chapter 5 "Lock-Free Memory Reclamation" Thesis for the degree of Doctor of Philosophy</li>
</ul>
</dd></dl>
<dl class="user"><dt><b>Template parameters:</b></dt><dd><ul>
<li><code>T</code> Type of data saved in queue's node </li>
<li><code>TRAITS</code> Traits class (see HRCQueueTraits) </li>
<li><code>ALLOCATOR</code> Memory allocator template. This implementation assumes that memory allocator is a wrapper of global object (singleton)</li>
</ul>
This algorithm is the integration of Michael's hazard pointer scheme and reference counting method. Hazard pointers are used for guaranteeing the safety of local references and reference counts for guaranteeing the safety of internal links in the data structure. The reference count of each node should indicate the number of globally accessible links that reference that node. The reference count mechanism allows to introduce concurrent iterator concept into queue implementation. </dd></dl>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="ae9015fc6885a7176d46adc2161d94fcc"></a><!-- doxytag: member="cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;::TThreadGC" ref="ae9015fc6885a7176d46adc2161d94fcc" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcds_1_1gc_1_1hrc_1_1_thread_g_c.html">cds::gc::hrc::ThreadGC</a> cds::queue::MSQueue&lt; <a class="el" href="structcds_1_1gc_1_1hrc__gc.html">gc::hrc_gc</a>, T, TRAITS, ALLOCATOR &gt;::<a class="el" href="classcds_1_1gc_1_1hrc_1_1_thread_g_c.html">TThreadGC</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Memory allocation driver </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a587222570bd26d1edd6d8133ee4dd9ea"></a><!-- doxytag: member="cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;::dequeue" ref="a587222570bd26d1edd6d8133ee4dd9ea" args="(T &amp;dest)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cds::queue::MSQueue&lt; <a class="el" href="structcds_1_1gc_1_1hrc__gc.html">gc::hrc_gc</a>, T, TRAITS, ALLOCATOR &gt;::dequeue </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"> <em>dest</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Dequeues a value to <code>dest</code>. If queue is empty returns <em>false</em>, <code>dest</code> is unchanged. If queue is not empty returns <em>true</em>, <code>dest</code> contains the value dequeued </p>

<p>Reimplemented in <a class="el" href="classcds_1_1queue_1_1_moir_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4.html#aca6c70e11388532d991630ea8816ed23">cds::queue::MoirQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/queue/msqueue_hrc.h</li>
</ul>
</div>
		<hr/>
		<div align="right">
			<b>cds</b> <b>0.7.0</b> 
			Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2010
			<br/>
			<i>Autogenerated Sun Dec 5 2010 11:36:38 by Doxygen 1.7.2</i>
		</div>
	</BODY>
</HTML>

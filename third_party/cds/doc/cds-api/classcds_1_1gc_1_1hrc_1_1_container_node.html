<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cds: cds::gc::hrc::ContainerNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacecds.html">cds</a>      </li>
      <li><a class="el" href="namespacecds_1_1gc.html">gc</a>      </li>
      <li><a class="el" href="namespacecds_1_1gc_1_1hrc.html">hrc</a>      </li>
      <li><a class="el" href="classcds_1_1gc_1_1hrc_1_1_container_node.html">ContainerNode</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>cds::gc::hrc::ContainerNode Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="cds::gc::hrc::ContainerNode" -->
<p>Base class for all HRC-based container's node.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;hrc.h&gt;</code></p>
<!-- startSectionHeader --><div class="dynheader">
Inheritance diagram for cds::gc::hrc::ContainerNode:<!-- endSectionHeader --></div>
<!-- startSectionSummary --><!-- endSectionSummary --><!-- startSectionContent --><div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1gc_1_1hrc_1_1_container_node.png" usemap="#cds::gc::hrc::ContainerNode_map" alt=""/>
  <map id="cds::gc::hrc::ContainerNode_map" name="cds::gc::hrc::ContainerNode_map">
<area href="classcds_1_1gc_1_1hrc_1_1_container_node_t.html" alt="cds::gc::hrc::ContainerNodeT&lt; T, ALLOCATOR &gt;" shape="rect" coords="0,56,407,80"/>
<area href="classcds_1_1gc_1_1hrc_1_1_container_node_t.html" alt="cds::gc::hrc::ContainerNodeT&lt; Node, ALLOCATOR &gt;" shape="rect" coords="417,56,824,80"/>
<area href="structcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4_1_1_node.html" alt="cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;::Node" shape="rect" coords="417,112,824,136"/>
</map>
 </div><!-- endSectionContent --></div>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adec6dc6af0514b514290d2e0bbf82440"></a><!-- doxytag: member="cds::gc::hrc::ContainerNode::getRefCount" ref="adec6dc6af0514b514290d2e0bbf82440" args="() const " -->
<a class="el" href="classcds_1_1ref__counter.html#a02040f002702143eb4a1be493738f8d3">unsigned_ref_counter::ref_counter_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_container_node.html#adec6dc6af0514b514290d2e0bbf82440">getRefCount</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns count of reference for the node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acfbffeb69902756b26a701c0b31cb270"></a><!-- doxytag: member="cds::gc::hrc::ContainerNode::incRefCount" ref="acfbffeb69902756b26a701c0b31cb270" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_container_node.html#acfbffeb69902756b26a701c0b31cb270">incRefCount</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the reference counter of the node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="affe30691ea4d724522ef1d5f97e18073"></a><!-- doxytag: member="cds::gc::hrc::ContainerNode::decRefCount" ref="affe30691ea4d724522ef1d5f97e18073" args="()" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_container_node.html#affe30691ea4d724522ef1d5f97e18073">decRefCount</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements the reference counter of the node. Returns <code>true</code> if ref counter is 0. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1f02401597a5853a4ef068382919651"></a><!-- doxytag: member="cds::gc::hrc::ContainerNode::isDeleted" ref="ad1f02401597a5853a4ef068382919651" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_container_node.html#ad1f02401597a5853a4ef068382919651">isDeleted</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mark that the node is deleted or not. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61df62411080f622ebd53dcc83a4ad33"></a><!-- doxytag: member="cds::gc::hrc::ContainerNode::destroy" ref="a61df62411080f622ebd53dcc83a4ad33" args="()=0" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_container_node.html#a61df62411080f622ebd53dcc83a4ad33">destroy</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to destroy (deallocate) node. Depends on node's allocator. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_container_node.html#a609759a95717e9a41e9dd2ae4b455e06">cleanUp</a> (<a class="el" href="classcds_1_1gc_1_1hrc_1_1_thread_g_c.html">ThreadGC</a> *pGC)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_container_node.html#a249bcf5fd2c73f30648f9a07547cf181">terminate</a> (<a class="el" href="classcds_1_1gc_1_1hrc_1_1_thread_g_c.html">ThreadGC</a> *pGC, bool bConcurrent)=0</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa68da8ab5747b8d3c39f338c2a2b093f"></a><!-- doxytag: member="cds::gc::hrc::ContainerNode::m_RC" ref="aa68da8ab5747b8d3c39f338c2a2b093f" args="" -->
<a class="el" href="classcds_1_1ref__counter.html">unsigned_ref_counter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_container_node.html#aa68da8ab5747b8d3c39f338c2a2b093f">m_RC</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">reference counter <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ab90123d027812a49722565a3f909ad"></a><!-- doxytag: member="cds::gc::hrc::ContainerNode::m_bTrace" ref="a5ab90123d027812a49722565a3f909ad" args="" -->
<a class="el" href="classcds_1_1atomic.html">atomic</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_container_node.html#a5ab90123d027812a49722565a3f909ad">m_bTrace</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>true</em> - node is tracing by HRC <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe9056cf087d6ff5c1f0f30962b644c4"></a><!-- doxytag: member="cds::gc::hrc::ContainerNode::m_bDeleted" ref="afe9056cf087d6ff5c1f0f30962b644c4" args="" -->
<a class="el" href="classcds_1_1atomic.html">atomic</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_container_node.html#afe9056cf087d6ff5c1f0f30962b644c4">m_bDeleted</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">@ true - node is deleted <br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed63c75a6d93c19ed9b14ec512386a34"></a><!-- doxytag: member="cds::gc::hrc::ContainerNode::GarbageCollector" ref="aed63c75a6d93c19ed9b14ec512386a34" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><b>GarbageCollector</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d476ed6cac2fbf542b878b1664eb3c3"></a><!-- doxytag: member="cds::gc::hrc::ContainerNode::ThreadGC" ref="a3d476ed6cac2fbf542b878b1664eb3c3" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><b>ThreadGC</b></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Base class for all HRC-based container's node. </p>
<p>This interface is placed to the <a class="el" href="classcds_1_1gc_1_1hrc_1_1_container_node.html" title="Base class for all HRC-based container&#39;s node.">ContainerNode</a> class since the lifetime of the node is greater than lifetime of its container. Reclaimed node may be physically deleted later than its container. So, the <a class="el" href="classcds_1_1gc_1_1hrc_1_1_container_node.html" title="Base class for all HRC-based container&#39;s node.">ContainerNode</a> must be "clever" than usual. </p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a609759a95717e9a41e9dd2ae4b455e06"></a><!-- doxytag: member="cds::gc::hrc::ContainerNode::cleanUp" ref="a609759a95717e9a41e9dd2ae4b455e06" args="(ThreadGC *pGC)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cds::gc::hrc::ContainerNode::cleanUp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_thread_g_c.html">ThreadGC</a> *&#160;</td>
          <td class="paramname"> <em>pGC</em>&#160;)</td>
          <td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>[Gidenstam 2006]: "The procedure <code>CleanUpNode</code> will make sure that all claimed references from the links of the given node will only point to active nodes, thus removing redundant passages through an arbitrary number of deleted nodes"</p>
<p>The pseudocode of this method must be like following: </p>
<div class="fragment"><pre class="fragment">                <span class="keywordtype">void</span> <a class="code" href="classcds_1_1gc_1_1hrc_1_1_container_node.html#a609759a95717e9a41e9dd2ae4b455e06">cleanUp</a>( ThreadGC * pGC )
                    <span class="keywordflow">for</span> all x where link[x] of node is reference-counted <span class="keywordflow">do</span>
                retry:
                        node1 := link[x]    ;
                        <span class="keywordflow">if</span> node1 != NULL and node1.m_bDeleted then
                            node2 := node1-&gt;link[x]    ;
                            pGC-&gt;CASRef( this-&gt;link[x], node1, node2 );
                            pGC-&gt;releaseRef( node2 );
                            pGC-&gt;releaseRef( node1 );
                            <span class="keywordflow">goto</span> retry;
                        pGC-&gt;releaseRef(node1);
</pre></div><p>Be aware to use hazard pointers inside implementation of this method. cleanUp is called from the container's method when deleting the nodes. However, some hazard pointers may be occupied by container's method. You should allocate new hazard pointers inside cleanUp method, for example: </p>
<div class="fragment"><pre class="fragment"> gc::hrc::AutoHPArray&lt;2&gt; hpArr( *pGC )    ; 
</pre></div> 
<p>Implemented in <a class="el" href="structcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4_1_1_node.html#a41c1f2de1ed6e9175223c5095a08a1a3">cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;::Node</a>.</p>

</div>
</div>
<a class="anchor" id="a249bcf5fd2c73f30648f9a07547cf181"></a><!-- doxytag: member="cds::gc::hrc::ContainerNode::terminate" ref="a249bcf5fd2c73f30648f9a07547cf181" args="(ThreadGC *pGC, bool bConcurrent)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cds::gc::hrc::ContainerNode::terminate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1gc_1_1hrc_1_1_thread_g_c.html">ThreadGC</a> *&#160;</td>
          <td class="paramname"> <em>pGC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>bConcurrent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>[Gidenstam 2006]: "The procedure <code>TerminateNode</code> will make sure that none of the links in the given node will have any claim on any other node. TerminateNode is called on a deleted node when there are no claims from any other node or thread to the node"</p>
<p>The pseudocode of this method must be like following: </p>
<div class="fragment"><pre class="fragment">                <span class="keywordtype">void</span> <a class="code" href="classcds_1_1gc_1_1hrc_1_1_container_node.html#a249bcf5fd2c73f30648f9a07547cf181">terminate</a>( ThreadGC * pGC, <span class="keywordtype">bool</span> bConcurrent)
                    <span class="keywordflow">if</span> !bConcurrent
                        <span class="keywordflow">for</span> all this-&gt;link where link is reference-counted <span class="keywordflow">do</span>
                            link := NULL ;
                    <span class="keywordflow">else</span>
                        <span class="keywordflow">for</span> all this-&gt;link where link is reference-counted <span class="keywordflow">do</span>
                            repeat node1 := link ;
                            until pGC-&gt;CASRef(link,node1,NULL);
</pre></div> 
<p>Implemented in <a class="el" href="structcds_1_1queue_1_1_m_s_queue_3_01gc_1_1hrc__gc_00_01_t_00_01_t_r_a_i_t_s_00_01_a_l_l_o_c_a_t_o_r_01_4_1_1_node.html#a1025db047531ea4635acb6ec15cf440c">cds::queue::MSQueue&lt; gc::hrc_gc, T, TRAITS, ALLOCATOR &gt;::Node</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/gc/hrc/hrc.h</li>
</ul>
</div>
		<hr/>
		<div align="right">
			<b>cds</b> <b>0.7.0</b> 
			Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2010
			<br/>
			<i>Autogenerated Sun Dec 5 2010 11:36:31 by Doxygen 1.7.2</i>
		</div>
	</BODY>
</HTML>

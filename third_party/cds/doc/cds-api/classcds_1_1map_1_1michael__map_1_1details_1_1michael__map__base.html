<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cds: cds::map::michael_map::details::michael_map_base&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacecds.html">cds</a>      </li>
      <li><a class="el" href="namespacecds_1_1map.html">map</a>      </li>
      <li><a class="el" href="namespacecds_1_1map_1_1michael__map.html">michael_map</a>      </li>
      <li><a class="el" href="namespacecds_1_1map_1_1michael__map_1_1details.html">details</a>      </li>
      <li><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html">michael_map_base</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<h1>cds::map::michael_map::details::michael_map_base&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="cds::map::michael_map::details::michael_map_base" --><!-- doxytag: inherits="cds::map::map_base" -->
<p>Base of Michael's hash map.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;michael_hash_map.h&gt;</code></p>
<!-- startSectionHeader --><div class="dynheader">
Inheritance diagram for cds::map::michael_map::details::michael_map_base&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;:<!-- endSectionHeader --></div>
<!-- startSectionSummary --><!-- endSectionSummary --><!-- startSectionContent --><div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.png" usemap="#cds::map::michael_map::details::michael_map_base&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;_map" alt=""/>
  <map id="cds::map::michael_map::details::michael_map_base&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;_map" name="cds::map::michael_map::details::michael_map_base&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;_map">
<area href="structcds_1_1map_1_1map__base.html" alt="cds::map::map_base&lt; KEY, VALUE, PAIR_TRAITS, TRAITS &gt;" shape="rect" coords="338,56,1005,80"/>
<area href="structcds_1_1map_1_1map__tag.html" alt="cds::map::map_tag" shape="rect" coords="338,0,1005,24"/>
<area href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__gc.html" alt="cds::map::michael_map::details::michael_map_gc&lt; GC, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;" shape="rect" coords="0,168,667,192"/>
<area href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__gc_3_01gc_1_1no__gc_00_01_k_e_y_00_035e56e09eaf245e519ec7d1ffd8cdfec.html" alt="cds::map::michael_map::details::michael_map_gc&lt; gc::no_gc, KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;" shape="rect" coords="677,168,1344,192"/>
</map>
 </div><!-- endSectionContent --></div>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base_1_1_non_concurrent_iterator.html">NonConcurrentIterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-concurrent iterator.  <a href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base_1_1_non_concurrent_iterator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base_1_1type__traits.html">type_traits</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Map traits.  <a href="structcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base_1_1type__traits.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9f583a181839d1792cdbf6402f7ca6a"></a><!-- doxytag: member="cds::map::michael_map::details::michael_map_base::key_type" ref="ae9f583a181839d1792cdbf6402f7ca6a" args="" -->
typedef base_class::key_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html#ae9f583a181839d1792cdbf6402f7ca6a">key_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">key type <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace8db2439ef8a45f5be743a1fbecee3d"></a><!-- doxytag: member="cds::map::michael_map::details::michael_map_base::value_type" ref="ace8db2439ef8a45f5be743a1fbecee3d" args="" -->
typedef base_class::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html#ace8db2439ef8a45f5be743a1fbecee3d">value_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">value_type <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a085b09f3d0a619f88899a5c80c1aa66e"></a><!-- doxytag: member="cds::map::michael_map::details::michael_map_base::pair_traits" ref="a085b09f3d0a619f88899a5c80c1aa66e" args="" -->
typedef base_class::pair_traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html#a085b09f3d0a619f88899a5c80c1aa66e">pair_traits</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">pair traits <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e50d1235136a5e1ea5a407d5b985cea"></a><!-- doxytag: member="cds::map::michael_map::details::michael_map_base::bucket_type" ref="a3e50d1235136a5e1ea5a407d5b985cea" args="" -->
typedef <a class="el" href="structcds_1_1map_1_1type__traits.html#a5d402e50d8c69701bf4edfe45d101a49">type_traits::bucket_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html#a3e50d1235136a5e1ea5a407d5b985cea">bucket_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bucket implementation (ordered list with GC) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6864dc35ab480d6f14df4ee949cab800"></a><!-- doxytag: member="cds::map::michael_map::details::michael_map_base::ordered_list_type" ref="a6864dc35ab480d6f14df4ee949cab800" args="" -->
typedef <a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html#a3e50d1235136a5e1ea5a407d5b985cea">bucket_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html#a6864dc35ab480d6f14df4ee949cab800">ordered_list_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordered list implementation (same as bucket_type) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac09ce9e72dcf321db0e55ee603ee1159"></a><!-- doxytag: member="cds::map::michael_map::details::michael_map_base::gc_schema" ref="ac09ce9e72dcf321db0e55ee603ee1159" args="" -->
typedef <a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1bucket__selector.html#a91a8ee8822cd446013ea487e0bc891c1">bucket_selector::gc_schema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html#ac09ce9e72dcf321db0e55ee603ee1159">gc_schema</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory reclamation schema. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a1c9d4850fea942a47d56ccfff55aa6"></a><!-- doxytag: member="cds::map::michael_map::details::michael_map_base::item_counter_type" ref="a9a1c9d4850fea942a47d56ccfff55aa6" args="" -->
typedef <br class="typebreak"/>
<a class="el" href="structcds_1_1map_1_1type__traits.html#abb967df4eed555df919217b8132bf9c6">type_traits::item_counter_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html#a9a1c9d4850fea942a47d56ccfff55aa6">item_counter_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter implementation. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aefb3edfe91d4952f7559ebe0feaf786a"></a><!-- doxytag: member="cds::map::michael_map::details::michael_map_base::statistics" ref="aefb3edfe91d4952f7559ebe0feaf786a" args="" -->
typedef <a class="el" href="structcds_1_1map_1_1empty__statistics.html">type_traits::statistics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html#aefb3edfe91d4952f7559ebe0feaf786a">statistics</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal statistics implementation. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9cbf3c510441d57d74c92d3603f96ee5"></a><!-- doxytag: member="cds::map::michael_map::details::michael_map_base::michael_map_base" ref="a9cbf3c510441d57d74c92d3603f96ee5" args="(size_t nBucketCount=1024)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html#a9cbf3c510441d57d74c92d3603f96ee5">michael_map_base</a> (size_t nBucketCount=1024)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit bucket count definition. <code>nBucketCount</code> must be power of 2. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html#a5e25f5b0787bdec3aa6a996927bcefa5">michael_map_base</a> (size_t nMaxItemCount, size_t nLoadFactor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate bucket count according to parameter passed.  <a href="#a5e25f5b0787bdec3aa6a996927bcefa5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1eb1371dcda1cba8525ad7b4f58af09"></a><!-- doxytag: member="cds::map::michael_map::details::michael_map_base::~michael_map_base" ref="ae1eb1371dcda1cba8525ad7b4f58af09" args="()" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html#ae1eb1371dcda1cba8525ad7b4f58af09">~michael_map_base</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructs the map. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html#ae311d2d1e1e5639702e4e56624ec0b8b">bucket_count</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns current bucket count.  <a href="#ae311d2d1e1e5639702e4e56624ec0b8b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html#a242fd7d505e214745829644bcb63b9c5">max_bucket_count</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns maximum bucket count.  <a href="#a242fd7d505e214745829644bcb63b9c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ad21a5171e5fca4ef817db9afcf25a2"></a><!-- doxytag: member="cds::map::michael_map::details::michael_map_base::insert" ref="a3ad21a5171e5fca4ef817db9afcf25a2" args="(const KEY &amp;key, const VALUE &amp;val)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html#a3ad21a5171e5fca4ef817db9afcf25a2">insert</a> (const KEY &amp;key, const VALUE &amp;val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts pair &lt;<code>key</code>, <code>val&gt;</code> into the map. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename FUNC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html#a6197bb7a50d8695b2250fdbe01cbede0">ensure</a> (const KEY &amp;key, const VALUE &amp;val, FUNC func)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that key <code>key</code> exists in the map.  <a href="#a6197bb7a50d8695b2250fdbe01cbede0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename FUNC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html#a8adb3c38e7a31a1379dbdc5cd2e112c5">emplace</a> (const KEY &amp;key, const T &amp;val, FUNC func)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplaces the vale of key <code>key</code> with new value <code>val</code>.  <a href="#a8adb3c38e7a31a1379dbdc5cd2e112c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3566985251a40bcf166db629c287032d"></a><!-- doxytag: member="cds::map::michael_map::details::michael_map_base::find" ref="a3566985251a40bcf166db629c287032d" args="(const KEY &amp;key)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html#a3566985251a40bcf166db629c287032d">find</a> (const KEY &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the key <code>key</code> exists in the map. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9b3cf4eefb6b944ae3c4c228894a9ce"></a><!-- doxytag: member="cds::map::michael_map::details::michael_map_base::empty" ref="af9b3cf4eefb6b944ae3c4c228894a9ce" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html#af9b3cf4eefb6b944ae3c4c228894a9ce">empty</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the map is empty. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html#ac37acb1116a3f8583809b211b0bd545a">size</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the map.  <a href="#ac37acb1116a3f8583809b211b0bd545a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2cbce05616872e1134c028a0f848ed6"></a><!-- doxytag: member="cds::map::michael_map::details::michael_map_base::clear" ref="af2cbce05616872e1134c028a0f848ed6" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html#af2cbce05616872e1134c028a0f848ed6">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all items in the map. Not thread safe!!! <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Debug methods. NOT thread safe!!!</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structcds_1_1map_1_1empty__statistics.html">statistics</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html#aa5728c570bd72ab1e85ee08be71fe702">getStatistics</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns internal statistics.  <a href="#aa5728c570bd72ab1e85ee08be71fe702"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html#a25c04cf696257c4dc3d36f7a6f502b51">dump</a> (std::ostream &amp;stm)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumping the internal content of split list to stream <code>stm</code>. Debugging method.  <a href="#a25c04cf696257c4dc3d36f7a6f502b51"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53fedc6199521aa0dd3a00f6e20926ea"></a><!-- doxytag: member="cds::map::michael_map::details::michael_map_base::hashValue" ref="a53fedc6199521aa0dd3a00f6e20926ea" args="(const KEY &amp;key) const " -->
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html#a53fedc6199521aa0dd3a00f6e20926ea">hashValue</a> (const KEY &amp;key) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns hash value for <code>key</code>. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aabe06c2ae84f46a57e6720bb8e7ca3c4"></a><!-- doxytag: member="cds::map::michael_map::details::michael_map_base::calcMask" ref="aabe06c2ae84f46a57e6720bb8e7ca3c4" args="(size_t nItemCount, size_t nLoadFactor)" -->
static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html#aabe06c2ae84f46a57e6720bb8e7ca3c4">calcMask</a> (size_t nItemCount, size_t nLoadFactor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate mask for hash value. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56ed05b4494aab936e389e4f495ac631"></a><!-- doxytag: member="cds::map::michael_map::details::michael_map_base::m_funcHash" ref="a56ed05b4494aab936e389e4f495ac631" args="" -->
base_class::hash_functor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html#a56ed05b4494aab936e389e4f495ac631">m_funcHash</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">hash function <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b8423293cffee585ba0bb2cbf2ba8e1"></a><!-- doxytag: member="cds::map::michael_map::details::michael_map_base::m_nMask" ref="a4b8423293cffee585ba0bb2cbf2ba8e1" args="" -->
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html#a4b8423293cffee585ba0bb2cbf2ba8e1">m_nMask</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">mask for hash value ( 2**N - 1) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67dd7a8613e45f62bba7225026335bb7"></a><!-- doxytag: member="cds::map::michael_map::details::michael_map_base::m_HashTable" ref="a67dd7a8613e45f62bba7225026335bb7" args="" -->
hash_table_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html#a67dd7a8613e45f62bba7225026335bb7">m_HashTable</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">hash table <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3624366b2ede8aade8bded40d177088b"></a><!-- doxytag: member="cds::map::michael_map::details::michael_map_base::m_Statistics" ref="a3624366b2ede8aade8bded40d177088b" args="" -->
<a class="el" href="structcds_1_1map_1_1empty__statistics.html">statistics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html#a3624366b2ede8aade8bded40d177088b">m_Statistics</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal statistics. <br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Non-concurrent iterators</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base_1_1_non_concurrent_iterator.html">NonConcurrentIterator</a><br class="typebreak"/>
&lt; <a class="el" href="structcds_1_1map_1_1map__base.html#a992f33fa7e2cbd954606e850836ac5ff">value_type</a> &amp;, typename <br class="typebreak"/>
ordered_list_type::nonconcurrent_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html#a5b78d4595bbe358c91b74adbc85c1888">nonconcurrent_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-concurrent iterator.  <a href="#a5b78d4595bbe358c91b74adbc85c1888"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base_1_1_non_concurrent_iterator.html">NonConcurrentIterator</a><br class="typebreak"/>
&lt; const <a class="el" href="structcds_1_1map_1_1map__base.html#a992f33fa7e2cbd954606e850836ac5ff">value_type</a> &amp;, typename <br class="typebreak"/>
ordered_list_type::nonconcurrent_const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html#aa396db2ba8f3bf10086af1a9ff91d6fe">nonconcurrent_const_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-concurrent iterator.  <a href="#aa396db2ba8f3bf10086af1a9ff91d6fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base_1_1_non_concurrent_iterator.html">nonconcurrent_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html#a71b55b15c9db0418e39c92ea28f399b9">nc_begin</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-concurrent forward start iterator.  <a href="#a71b55b15c9db0418e39c92ea28f399b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base_1_1_non_concurrent_iterator.html">nonconcurrent_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html#aa6778c0d396fa9063e36f4de4b644548">nc_end</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-concurrent forward end iterator.  <a href="#aa6778c0d396fa9063e36f4de4b644548"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base_1_1_non_concurrent_iterator.html">nonconcurrent_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html#acd24eae637803771712422beb73b23e1">nc_begin</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-concurrent const forward start iterator.  <a href="#acd24eae637803771712422beb73b23e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base_1_1_non_concurrent_iterator.html">nonconcurrent_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html#a5d444c8a0ae20fb8c4bd637f04af5751">nc_end</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-concurrent const forward end iterator.  <a href="#a5d444c8a0ae20fb8c4bd637f04af5751"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename KEY, typename VALUE, typename PAIR_TRAITS, typename TRAITS, class ALLOCATOR&gt;<br/>
 class cds::map::michael_map::details::michael_map_base&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;</h3>

<p>Base of Michael's hash map. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="aa396db2ba8f3bf10086af1a9ff91d6fe"></a><!-- doxytag: member="cds::map::michael_map::details::michael_map_base::nonconcurrent_const_iterator" ref="aa396db2ba8f3bf10086af1a9ff91d6fe" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base_1_1_non_concurrent_iterator.html">NonConcurrentIterator</a>&lt; const <a class="el" href="structcds_1_1map_1_1map__base.html#a992f33fa7e2cbd954606e850836ac5ff">value_type</a>&amp;, typename ordered_list_type::nonconcurrent_const_iterator &gt; <a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html">cds::map::michael_map::details::michael_map_base</a>&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::<a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base_1_1_non_concurrent_iterator.html">nonconcurrent_const_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Non-concurrent iterator. </p>
<p>This iterator is not thread-safe. </p>

</div>
</div>
<a class="anchor" id="a5b78d4595bbe358c91b74adbc85c1888"></a><!-- doxytag: member="cds::map::michael_map::details::michael_map_base::nonconcurrent_iterator" ref="a5b78d4595bbe358c91b74adbc85c1888" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base_1_1_non_concurrent_iterator.html">NonConcurrentIterator</a>&lt; <a class="el" href="structcds_1_1map_1_1map__base.html#a992f33fa7e2cbd954606e850836ac5ff">value_type</a>&amp;, typename ordered_list_type::nonconcurrent_iterator &gt; <a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html">cds::map::michael_map::details::michael_map_base</a>&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::<a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base_1_1_non_concurrent_iterator.html">nonconcurrent_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Non-concurrent iterator. </p>
<p>This iterator is not thread-safe. </p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5e25f5b0787bdec3aa6a996927bcefa5"></a><!-- doxytag: member="cds::map::michael_map::details::michael_map_base::michael_map_base" ref="a5e25f5b0787bdec3aa6a996927bcefa5" args="(size_t nMaxItemCount, size_t nLoadFactor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html">cds::map::michael_map::details::michael_map_base</a>&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::<a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html">michael_map_base</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"> <em>nMaxItemCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"> <em>nLoadFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate bucket count according to parameter passed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nMaxItemCount</td><td>estimation of max item count in the hash map </td></tr>
    <tr><td class="paramname">nLoadFactor</td><td>load factor: estimation of max number of items in the bucket </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae311d2d1e1e5639702e4e56624ec0b8b"></a><!-- doxytag: member="cds::map::michael_map::details::michael_map_base::bucket_count" ref="ae311d2d1e1e5639702e4e56624ec0b8b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html">cds::map::michael_map::details::michael_map_base</a>&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns current bucket count. </p>
<p>Michael's hash map cannot dynamically extend the size of hash array. Therefore, <a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html#ae311d2d1e1e5639702e4e56624ec0b8b" title="Returns current bucket count.">bucket_count()</a> == <a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html#a242fd7d505e214745829644bcb63b9c5" title="Returns maximum bucket count.">max_bucket_count()</a> </p>

</div>
</div>
<a class="anchor" id="a25c04cf696257c4dc3d36f7a6f502b51"></a><!-- doxytag: member="cds::map::michael_map::details::michael_map_base::dump" ref="a25c04cf696257c4dc3d36f7a6f502b51" args="(std::ostream &amp;stm)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; <a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html">cds::map::michael_map::details::michael_map_base</a>&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::dump </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"> <em>stm</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dumping the internal content of split list to stream <code>stm</code>. Debugging method. </p>
<p>Not implemented </p>

</div>
</div>
<a class="anchor" id="a8adb3c38e7a31a1379dbdc5cd2e112c5"></a><!-- doxytag: member="cds::map::michael_map::details::michael_map_base::emplace" ref="a8adb3c38e7a31a1379dbdc5cd2e112c5" args="(const KEY &amp;key, const T &amp;val, FUNC func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename FUNC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html">cds::map::michael_map::details::michael_map_base</a>&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">const KEY &amp;&#160;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNC&#160;</td>
          <td class="paramname"> <em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Emplaces the vale of key <code>key</code> with new value <code>val</code>. </p>
<p>The operation changes the value (or a part of the value) of key <code>key</code> to new one <code>val</code>. The user-defined functor <code>func</code> has the purpose like <code>func</code> argument of <a class="el" href="ordered_list_common_interface.html#ensure">ensure</a> member function. The signature of <code>func</code> is </p>
<div class="fragment"><pre class="fragment">                        <span class="keywordtype">void</span> func( VALUE&amp; itemValue, <span class="keyword">const</span> T&amp; val ) ;
</pre></div><p> The first argument <code>itemValue</code> of user-defined function <code>func</code> is the reference to the map's item pointed by key <code>key</code>. The second argument <code>val</code> is the value passed to <code>emplace</code> member function. User-defined function <code>func</code> must guarantee that during changing key's value no any other changes could be made on this map's item by concurrent threads. The list only guarantees that the item found by key cannot be deleted while <code>func</code> working</p>
<p>The function returns <code>true</code> if the key <code>key</code> exists in the map and <code>false</code> otherwise </p>

</div>
</div>
<a class="anchor" id="a6197bb7a50d8695b2250fdbe01cbede0"></a><!-- doxytag: member="cds::map::michael_map::details::michael_map_base::ensure" ref="a6197bb7a50d8695b2250fdbe01cbede0" args="(const KEY &amp;key, const VALUE &amp;val, FUNC func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR &gt; </div>
<div class="memtemplate">
template&lt;typename FUNC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, bool&gt; <a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html">cds::map::michael_map::details::michael_map_base</a>&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::ensure </td>
          <td>(</td>
          <td class="paramtype">const KEY &amp;&#160;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE &amp;&#160;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNC&#160;</td>
          <td class="paramname"> <em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ensures that key <code>key</code> exists in the map. </p>
<p>If <code>key</code> exists in the map then changes the value of the item pointed by <code>key</code> to <code>val</code>. The change is performed by calling user-defined function <code>func</code> with signature: </p>
<div class="fragment"><pre class="fragment">                            <span class="keywordtype">void</span> func( VALUE&amp; itemValue, <span class="keyword">const</span> VALUE&amp; val ) ;
</pre></div><p> The first argument <code>itemValue</code> of user-defined function <code>func</code> is the reference to the map's item pointed by key <code>key</code>. The second argument <code>val</code> is the value passed to <code>ensure</code> member function. User-defined function <code>func</code> must guarantee that during changing key's value no any other changes could be made on this map item by concurrent threads. The user-defined function is called only if the key exists in the map.</p>
<p>If <code>key</code> is not in map then add it.</p>
<p>Returns std::pair&lt;bool, bool&gt; where <code>first</code> is true if operation is successfull, <code>second</code> is true if new item has been added or <code>false</code> if the item with <code>key</code> already in map. </p>

</div>
</div>
<a class="anchor" id="aa5728c570bd72ab1e85ee08be71fe702"></a><!-- doxytag: member="cds::map::michael_map::details::michael_map_base::getStatistics" ref="aa5728c570bd72ab1e85ee08be71fe702" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structcds_1_1map_1_1empty__statistics.html">statistics</a>&amp; <a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html">cds::map::michael_map::details::michael_map_base</a>&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::getStatistics </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns internal statistics. </p>
<p>Internal statistics struct is defined in <code>TRAITS::statistics</code>. </p>

</div>
</div>
<a class="anchor" id="a242fd7d505e214745829644bcb63b9c5"></a><!-- doxytag: member="cds::map::michael_map::details::michael_map_base::max_bucket_count" ref="a242fd7d505e214745829644bcb63b9c5" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html">cds::map::michael_map::details::michael_map_base</a>&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::max_bucket_count </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns maximum bucket count. </p>
<p>Michael's hash map cannot dynamically extend the size of hash array. Therefore, <a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html#ae311d2d1e1e5639702e4e56624ec0b8b" title="Returns current bucket count.">bucket_count()</a> == <a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html#a242fd7d505e214745829644bcb63b9c5" title="Returns maximum bucket count.">max_bucket_count()</a> </p>

</div>
</div>
<a class="anchor" id="a71b55b15c9db0418e39c92ea28f399b9"></a><!-- doxytag: member="cds::map::michael_map::details::michael_map_base::nc_begin" ref="a71b55b15c9db0418e39c92ea28f399b9" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base_1_1_non_concurrent_iterator.html">nonconcurrent_iterator</a> <a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html">cds::map::michael_map::details::michael_map_base</a>&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::nc_begin </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns non-concurrent forward start iterator. </p>
<p>For an empty list start iterator is equal to <em>end()</em>. </p>

</div>
</div>
<a class="anchor" id="acd24eae637803771712422beb73b23e1"></a><!-- doxytag: member="cds::map::michael_map::details::michael_map_base::nc_begin" ref="acd24eae637803771712422beb73b23e1" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base_1_1_non_concurrent_iterator.html">nonconcurrent_const_iterator</a> <a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html">cds::map::michael_map::details::michael_map_base</a>&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::nc_begin </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns non-concurrent const forward start iterator. </p>
<p>For an empty list start iterator is equal to <em>end()</em> </p>

</div>
</div>
<a class="anchor" id="a5d444c8a0ae20fb8c4bd637f04af5751"></a><!-- doxytag: member="cds::map::michael_map::details::michael_map_base::nc_end" ref="a5d444c8a0ae20fb8c4bd637f04af5751" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base_1_1_non_concurrent_iterator.html">nonconcurrent_const_iterator</a> <a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html">cds::map::michael_map::details::michael_map_base</a>&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::nc_end </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns non-concurrent const forward end iterator. </p>
<p>End iterator points to tail dummy node. You may use end iterator for comparison only </p>

</div>
</div>
<a class="anchor" id="aa6778c0d396fa9063e36f4de4b644548"></a><!-- doxytag: member="cds::map::michael_map::details::michael_map_base::nc_end" ref="aa6778c0d396fa9063e36f4de4b644548" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base_1_1_non_concurrent_iterator.html">nonconcurrent_iterator</a> <a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html">cds::map::michael_map::details::michael_map_base</a>&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::nc_end </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns non-concurrent forward end iterator. </p>
<p>End iterator points to tail dummy node. You may use end iterator for comparison only </p>

</div>
</div>
<a class="anchor" id="ac37acb1116a3f8583809b211b0bd545a"></a><!-- doxytag: member="cds::map::michael_map::details::michael_map_base::size" ref="ac37acb1116a3f8583809b211b0bd545a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1map_1_1michael__map_1_1details_1_1michael__map__base.html">cds::map::michael_map::details::michael_map_base</a>&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::size </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns item count in the map. </p>
<p>The return value of the method depends on item counter implementation. The item counter is defined in TRAITS::tiem_counter. If TRAITS::item_counter_type is <code>void</code> then dummy item counter <a class="el" href="classcds_1_1atomics_1_1empty__item__counter.html" title="Empty item counter.">cds::atomics::empty_item_counter</a> is used and this function returns dummy value (0 usually). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/map/michael_hash_map.h</li>
</ul>
</div>
		<hr/>
		<div align="right">
			<b>cds</b> <b>0.7.0</b> 
			Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2010
			<br/>
			<i>Autogenerated Sun Dec 5 2010 11:36:33 by Doxygen 1.7.2</i>
		</div>
	</BODY>
</HTML>

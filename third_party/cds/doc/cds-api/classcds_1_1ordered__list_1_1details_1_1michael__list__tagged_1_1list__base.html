<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cds: cds::ordered_list::details::michael_list_tagged::list_base&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacecds.html">cds</a>      </li>
      <li><a class="el" href="namespacecds_1_1ordered__list.html">ordered_list</a>      </li>
      <li><b>details</b>      </li>
      <li><b>michael_list_tagged</b>      </li>
      <li><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html">list_base</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<h1>cds::ordered_list::details::michael_list_tagged::list_base&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="cds::ordered_list::details::michael_list_tagged::list_base" --><!-- doxytag: inherits="cds::ordered_list::OrderedList" -->
<p>Michael's ordered list with Tagged Pointer GC.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;michael_list_tagged.h&gt;</code></p>
<!-- startSectionHeader --><div class="dynheader">
Inheritance diagram for cds::ordered_list::details::michael_list_tagged::list_base&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;:<!-- endSectionHeader --></div>
<!-- startSectionSummary --><!-- endSectionSummary --><!-- startSectionContent --><div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.png" usemap="#cds::ordered_list::details::michael_list_tagged::list_base&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;_map" alt=""/>
  <map id="cds::ordered_list::details::michael_list_tagged::list_base&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;_map" name="cds::ordered_list::details::michael_list_tagged::list_base&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;_map">
<area href="structcds_1_1ordered__list_1_1_ordered_list.html" alt="cds::ordered_list::OrderedList&lt; KEY, VALUE, TRAITS &gt;" shape="rect" coords="0,56,639,80"/>
<area href="structcds_1_1ordered__list_1_1ordered__list__tag.html" alt="cds::ordered_list::ordered_list_tag" shape="rect" coords="0,0,639,24"/>
</map>
 </div><!-- endSectionContent --></div>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base_1_1_non_concurrent_iterator.html">NonConcurrentIterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-concurrent iterator.  <a href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base_1_1_non_concurrent_iterator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base_1_1type__traits.html">type_traits</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">List type traits.  <a href="structcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base_1_1type__traits.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a6986755e6e061de7254bfcda1b726a"></a><!-- doxytag: member="cds::ordered_list::details::michael_list_tagged::list_base::Node" ref="a2a6986755e6e061de7254bfcda1b726a" args="" -->
typedef michael_list::Node<br class="typebreak"/>
&lt; <a class="el" href="structcds_1_1gc_1_1tagged__gc.html">gc::tagged_gc</a>, KEY, VALUE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html#a2a6986755e6e061de7254bfcda1b726a">Node</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Node type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70f728b220b68ffece3cbd7b33b875b3"></a><!-- doxytag: member="cds::ordered_list::details::michael_list_tagged::list_base::key_type" ref="a70f728b220b68ffece3cbd7b33b875b3" args="" -->
typedef base_class::key_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html#a70f728b220b68ffece3cbd7b33b875b3">key_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">key type <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e902a17ea0ce24a92c227f3aacb7331"></a><!-- doxytag: member="cds::ordered_list::details::michael_list_tagged::list_base::value_type" ref="a5e902a17ea0ce24a92c227f3aacb7331" args="" -->
typedef base_class::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html#a5e902a17ea0ce24a92c227f3aacb7331">value_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">value type <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a15c482e65ff73b3fb56101cf63e7f4"></a><!-- doxytag: member="cds::ordered_list::details::michael_list_tagged::list_base::pair_traits" ref="a8a15c482e65ff73b3fb56101cf63e7f4" args="" -->
typedef PAIR_TRAITS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html#a8a15c482e65ff73b3fb56101cf63e7f4">pair_traits</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pair traits type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6b95d5c049f723637f1cb367b97e6ff"></a><!-- doxytag: member="cds::ordered_list::details::michael_list_tagged::list_base::key_traits" ref="ad6b95d5c049f723637f1cb367b97e6ff" args="" -->
typedef pair_traits::key_traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html#ad6b95d5c049f723637f1cb367b97e6ff">key_traits</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Key traits. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b36e2949879ca07d99ff9095e11d20b"></a><!-- doxytag: member="cds::ordered_list::details::michael_list_tagged::list_base::value_traits" ref="a6b36e2949879ca07d99ff9095e11d20b" args="" -->
typedef pair_traits::value_traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html#a6b36e2949879ca07d99ff9095e11d20b">value_traits</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Value traits. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab12bd01cd3b9cad7de14198b174fccd5"></a><!-- doxytag: member="cds::ordered_list::details::michael_list_tagged::list_base::key_comparator" ref="ab12bd01cd3b9cad7de14198b174fccd5" args="" -->
typedef key_traits::key_comparator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html#ab12bd01cd3b9cad7de14198b174fccd5">key_comparator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Key comparator (binary predicate) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec9e2e64ca4e07a719baefda9c2d4c3a"></a><!-- doxytag: member="cds::ordered_list::details::michael_list_tagged::list_base::backoff_strategy" ref="aec9e2e64ca4e07a719baefda9c2d4c3a" args="" -->
typedef <br class="typebreak"/>
<a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1free__list__traits.html#a2ebbb7463dfa25e7c64ffab2d9122141">freelist_traits::backoff_strategy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html#aec9e2e64ca4e07a719baefda9c2d4c3a">backoff_strategy</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Back-off strategy. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a295f8d42c0990e7d87fa2c298f729d1b"></a><!-- doxytag: member="cds::ordered_list::details::michael_list_tagged::list_base::gc_schema" ref="a295f8d42c0990e7d87fa2c298f729d1b" args="" -->
typedef <a class="el" href="structcds_1_1gc_1_1tagged__gc.html">gc::tagged_gc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html#a295f8d42c0990e7d87fa2c298f729d1b">gc_schema</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collection schema. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base_1_1_non_concurrent_iterator.html">NonConcurrentIterator</a><br class="typebreak"/>
&lt; <a class="el" href="structcds_1_1ordered__list_1_1_ordered_list.html#a645a6ea2909d55fe856b360032434280">value_type</a> &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html#a31a09077816270487be8baab0caf6ec3">nonconcurrent_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-concurrent iterator.  <a href="#a31a09077816270487be8baab0caf6ec3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base_1_1_non_concurrent_iterator.html">NonConcurrentIterator</a><br class="typebreak"/>
&lt; const <a class="el" href="structcds_1_1ordered__list_1_1_ordered_list.html#a645a6ea2909d55fe856b360032434280">value_type</a> &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html#ac60a24b89667987313e5a6af16a920cf">nonconcurrent_const_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-concurrent iterator.  <a href="#ac60a24b89667987313e5a6af16a920cf"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeffaea4f487f6d3cde31efd6212218b0"></a><!-- doxytag: member="cds::ordered_list::details::michael_list_tagged::list_base::list_base" ref="aeffaea4f487f6d3cde31efd6212218b0" args="(typename type_traits::freelist_ref freeListRef)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html#aeffaea4f487f6d3cde31efd6212218b0">list_base</a> (typename <a class="el" href="structcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base_1_1type__traits.html#a8cb5d87d0f39a781a01ed28a86a730e9">type_traits::freelist_ref</a> freeListRef)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor with external free-list. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html#a512b0bea0a2c9265cebf8fc70af90a9e">insert</a> (const KEY &amp;key, const VALUE &amp;data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new item.  <a href="#a512b0bea0a2c9265cebf8fc70af90a9e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="af9f152b2e5f8623545b2a8f3bcf102c2"></a><!-- doxytag: member="cds::ordered_list::details::michael_list_tagged::list_base::ensure" ref="af9f152b2e5f8623545b2a8f3bcf102c2" args="(const KEY &amp;key, const VALUE &amp;val, FUNC func)" -->
template&lt;typename FUNC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html#af9f152b2e5f8623545b2a8f3bcf102c2">ensure</a> (const KEY &amp;key, const VALUE &amp;val, FUNC func)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that key <code>key</code> exists in list, changes data of existing item to <code>data</code>. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename FUNC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html#a527a1b7b448d2d58c346a3c809f34913">emplace</a> (const KEY &amp;key, const T &amp;val, FUNC func)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplaces the vale of key <code>key</code> with new value <code>val</code>.  <a href="#a527a1b7b448d2d58c346a3c809f34913"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html#ac11ac2aaa657eae83ca79ef2a1f85087">erase</a> (const KEY &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the key from list.  <a href="#ac11ac2aaa657eae83ca79ef2a1f85087"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62e0167e4013be5e171cb24ee0a306e4"></a><!-- doxytag: member="cds::ordered_list::details::michael_list_tagged::list_base::find" ref="a62e0167e4013be5e171cb24ee0a306e4" args="(const KEY &amp;key)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html#a62e0167e4013be5e171cb24ee0a306e4">find</a> (const KEY &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>key</code> exists in the list. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename FUNC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html#ab4c77fc923f23202440344819f6317da">find</a> (const KEY &amp;key, T &amp;data, FUNC func)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the data of item.  <a href="#ab4c77fc923f23202440344819f6317da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a169624e3a7c608362943078dff836304"></a><!-- doxytag: member="cds::ordered_list::details::michael_list_tagged::list_base::clear" ref="a169624e3a7c608362943078dff836304" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html#a169624e3a7c608362943078dff836304">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the list. Not thread safe!!! <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8975a34e83f2d18a5a75efe3670e0782"></a><!-- doxytag: member="cds::ordered_list::details::michael_list_tagged::list_base::empty" ref="a8975a34e83f2d18a5a75efe3670e0782" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html#a8975a34e83f2d18a5a75efe3670e0782">empty</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the list is empty. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base_1_1_non_concurrent_iterator.html">nonconcurrent_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html#a7dabccbe73aae7f6148e7a7ff85de3c6">nc_begin</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-concurrent forward start iterator.  <a href="#a7dabccbe73aae7f6148e7a7ff85de3c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base_1_1_non_concurrent_iterator.html">nonconcurrent_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html#ab528b7909cf5f971e51f1fcbdb78c42e">nc_end</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-concurrent forward end iterator.  <a href="#ab528b7909cf5f971e51f1fcbdb78c42e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base_1_1_non_concurrent_iterator.html">nonconcurrent_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html#aaebbf9e049cd9c47c14495000f8eae42">nc_begin</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-concurrent const forward start iterator.  <a href="#aaebbf9e049cd9c47c14495000f8eae42"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base_1_1_non_concurrent_iterator.html">nonconcurrent_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html#abba0b85bb58aa6eb23d2672c2403e05a">nc_end</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-concurrent const forward end iterator.  <a href="#abba0b85bb58aa6eb23d2672c2403e05a"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32067adb171c86fafb770597a7e2ef71"></a><!-- doxytag: member="cds::ordered_list::details::michael_list_tagged::list_base::tagged_node" ref="a32067adb171c86fafb770597a7e2ef71" args="" -->
typedef node_ptr&lt; <a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html#a2a6986755e6e061de7254bfcda1b726a">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html#a32067adb171c86fafb770597a7e2ef71">tagged_node</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tagged node type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a536dbde05d38cf1b089ed8d678780652"></a><!-- doxytag: member="cds::ordered_list::details::michael_list_tagged::list_base::freelist_traits" ref="a536dbde05d38cf1b089ed8d678780652" args="" -->
typedef <a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1free__list__traits.html">free_list_traits</a>&lt; <a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html#a2a6986755e6e061de7254bfcda1b726a">Node</a>, <br class="typebreak"/>
TRAITS &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html#a536dbde05d38cf1b089ed8d678780652">freelist_traits</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Free-list traits. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a030723196aa63a009ce91dad347d790f"></a><!-- doxytag: member="cds::ordered_list::details::michael_list_tagged::list_base::allocNode" ref="a030723196aa63a009ce91dad347d790f" args="(const KEY &amp;key, const VALUE &amp;data)" -->
<a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html#a2a6986755e6e061de7254bfcda1b726a">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html#a030723196aa63a009ce91dad347d790f">allocNode</a> (const KEY &amp;key, const VALUE &amp;data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates new node and initializes it by <code>key</code> and <code>data</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa52e70249e1c4aa3ec95e9baed28eb8a"></a><!-- doxytag: member="cds::ordered_list::details::michael_list_tagged::list_base::freeNode" ref="aa52e70249e1c4aa3ec95e9baed28eb8a" args="(Node *pNode)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html#aa52e70249e1c4aa3ec95e9baed28eb8a">freeNode</a> (<a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html#a2a6986755e6e061de7254bfcda1b726a">Node</a> *pNode)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the node <code>pNode</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fe89095005b8fe6e8aa57cf041b5291"></a><!-- doxytag: member="cds::ordered_list::details::michael_list_tagged::list_base::getHeadRef" ref="a8fe89095005b8fe6e8aa57cf041b5291" args="()" -->
<a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html#a32067adb171c86fafb770597a7e2ef71">tagged_node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html#a8fe89095005b8fe6e8aa57cf041b5291">getHeadRef</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">To inter-compiler compatibility. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29d25637815983a8a3ae91a3432293df"></a><!-- doxytag: member="cds::ordered_list::details::michael_list_tagged::list_base::m_pHead" ref="a29d25637815983a8a3ae91a3432293df" args="" -->
<a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html#a32067adb171c86fafb770597a7e2ef71">tagged_node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html#a29d25637815983a8a3ae91a3432293df">m_pHead</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">list head <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d83d617b7fa1914e9044b019eb5fc18"></a><!-- doxytag: member="cds::ordered_list::details::michael_list_tagged::list_base::m_Cmp" ref="a9d83d617b7fa1914e9044b019eb5fc18" args="" -->
<a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html#ab12bd01cd3b9cad7de14198b174fccd5">key_comparator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html#a9d83d617b7fa1914e9044b019eb5fc18">m_Cmp</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">key comparator <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94a142d9c01fbe46efd1ee922dbb965f"></a><!-- doxytag: member="cds::ordered_list::details::michael_list_tagged::list_base::m_FreeList" ref="a94a142d9c01fbe46efd1ee922dbb965f" args="" -->
<a class="el" href="structcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base_1_1type__traits.html#a8cb5d87d0f39a781a01ed28a86a730e9">type_traits::freelist_ref</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html#a94a142d9c01fbe46efd1ee922dbb965f">m_FreeList</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">reference to free-list implementation <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename KEY, typename VALUE, typename PAIR_TRAITS, typename TRAITS, class ALLOCATOR = CDS_DEFAULT_ALLOCATOR&gt;<br/>
 class cds::ordered_list::details::michael_list_tagged::list_base&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;</h3>

<p>Michael's ordered list with Tagged Pointer GC. </p>
<p>The class is internal implementation of MichaelList&lt;gc::tagged_gc&gt; and cannot be used directly. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="ac60a24b89667987313e5a6af16a920cf"></a><!-- doxytag: member="cds::ordered_list::details::michael_list_tagged::list_base::nonconcurrent_const_iterator" ref="ac60a24b89667987313e5a6af16a920cf" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR  = CDS_DEFAULT_ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base_1_1_non_concurrent_iterator.html">NonConcurrentIterator</a>&lt; const <a class="el" href="structcds_1_1ordered__list_1_1_ordered_list.html#a645a6ea2909d55fe856b360032434280">value_type</a>&amp; &gt; <a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html">cds::ordered_list::details::michael_list_tagged::list_base</a>&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::<a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base_1_1_non_concurrent_iterator.html">nonconcurrent_const_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Non-concurrent iterator. </p>
<p>This iterator is not thread-safe. While traversing the list by the iterator it should not delete the items from the list. Deleting an item pointed by iterator may result access violation. </p>

</div>
</div>
<a class="anchor" id="a31a09077816270487be8baab0caf6ec3"></a><!-- doxytag: member="cds::ordered_list::details::michael_list_tagged::list_base::nonconcurrent_iterator" ref="a31a09077816270487be8baab0caf6ec3" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR  = CDS_DEFAULT_ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base_1_1_non_concurrent_iterator.html">NonConcurrentIterator</a>&lt; <a class="el" href="structcds_1_1ordered__list_1_1_ordered_list.html#a645a6ea2909d55fe856b360032434280">value_type</a>&amp; &gt; <a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html">cds::ordered_list::details::michael_list_tagged::list_base</a>&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::<a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base_1_1_non_concurrent_iterator.html">nonconcurrent_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Non-concurrent iterator. </p>
<p>This iterator is not thread-safe. While traversing the list by the iterator it should not delete the items from the list. Deleting an item pointed by iterator may result access violation. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a527a1b7b448d2d58c346a3c809f34913"></a><!-- doxytag: member="cds::ordered_list::details::michael_list_tagged::list_base::emplace" ref="a527a1b7b448d2d58c346a3c809f34913" args="(const KEY &amp;key, const T &amp;val, FUNC func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR  = CDS_DEFAULT_ALLOCATOR&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename FUNC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html">cds::ordered_list::details::michael_list_tagged::list_base</a>&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">const KEY &amp;&#160;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNC&#160;</td>
          <td class="paramname"> <em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Emplaces the vale of key <code>key</code> with new value <code>val</code>. </p>
<p>The operation changes the value (or a part of the value) of key <code>key</code> to new one <code>val</code>. The user-defined functor <code>func</code> has the purpose like <code>func</code> argument of <a class="el" href="ordered_list_common_interface.html#ensure">ensure</a> member function. The signature of <code>func</code> is </p>
<div class="fragment"><pre class="fragment">                    <span class="keywordtype">void</span> func( VALUE&amp; itemValue, <span class="keyword">const</span> T&amp; val ) ;
</pre></div><p> The first argument <code>itemValue</code> of user-defined function <code>func</code> is the reference to the list's item pointed by key <code>key</code>. The second argument <code>val</code> is the value passed to <code>emplace</code> member function. User-defined function <code>func</code> must guarantee that during changing key's value no any other changes could be made on this list's item by concurrent threads. The list only garantees that the item found by key cannot be deleted while <code>func</code> worked</p>
<p>The function returns <code>true</code> if the key <code>key</code> exists in the list. </p>

</div>
</div>
<a class="anchor" id="ac11ac2aaa657eae83ca79ef2a1f85087"></a><!-- doxytag: member="cds::ordered_list::details::michael_list_tagged::list_base::erase" ref="ac11ac2aaa657eae83ca79ef2a1f85087" args="(const KEY &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR  = CDS_DEFAULT_ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html">cds::ordered_list::details::michael_list_tagged::list_base</a>&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const KEY &amp;&#160;</td>
          <td class="paramname"> <em>key</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deletes the key from list. </p>
<p>Removes <code>key</code> from the list. Returns <code>true</code> if an item with key <code>key</code> has been removed, and <code>false</code> if <code>key</code> is not in the list </p>

</div>
</div>
<a class="anchor" id="ab4c77fc923f23202440344819f6317da"></a><!-- doxytag: member="cds::ordered_list::details::michael_list_tagged::list_base::find" ref="ab4c77fc923f23202440344819f6317da" args="(const KEY &amp;key, T &amp;data, FUNC func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR  = CDS_DEFAULT_ALLOCATOR&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename FUNC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html">cds::ordered_list::details::michael_list_tagged::list_base</a>&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const KEY &amp;&#160;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNC&#160;</td>
          <td class="paramname"> <em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the data of item. </p>
<p>If <code>key</code> found the function calls user-defined function <code>func</code> with parameters: </p>
<div class="fragment"><pre class="fragment">                    <span class="keywordtype">void</span> func( T&amp; data, <span class="keyword">const</span> VALUE&amp; itemValue )
</pre></div><p> where <code>itemValue</code> is the item found by <code>key</code>. The user-defined function copies the item's value <code>itemValue</code> or its part to <code>data</code>. The list guarantees only that the item found cannot be deleted while <code>func</code> works. The user-defined function <code>func</code> should take into account that concurrent threads may change the item value.</p>
<p>Returns <code>true</code> if the key is found, <code>false</code> otherwise </p>

</div>
</div>
<a class="anchor" id="a512b0bea0a2c9265cebf8fc70af90a9e"></a><!-- doxytag: member="cds::ordered_list::details::michael_list_tagged::list_base::insert" ref="a512b0bea0a2c9265cebf8fc70af90a9e" args="(const KEY &amp;key, const VALUE &amp;data)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR  = CDS_DEFAULT_ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html">cds::ordered_list::details::michael_list_tagged::list_base</a>&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const KEY &amp;&#160;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE &amp;&#160;</td>
          <td class="paramname"> <em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inserts new item. </p>
<p>Inserts new item (<code>key</code>, <code>data</code>). Returns <code>true</code> if new item has been inserted, and <code>false</code> if an item with key <code>key</code> already in list. </p>

</div>
</div>
<a class="anchor" id="a7dabccbe73aae7f6148e7a7ff85de3c6"></a><!-- doxytag: member="cds::ordered_list::details::michael_list_tagged::list_base::nc_begin" ref="a7dabccbe73aae7f6148e7a7ff85de3c6" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR  = CDS_DEFAULT_ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base_1_1_non_concurrent_iterator.html">nonconcurrent_iterator</a> <a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html">cds::ordered_list::details::michael_list_tagged::list_base</a>&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::nc_begin </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns non-concurrent forward start iterator. </p>
<p>For an empty list start iterator is equal to <em>end()</em>. </p>

</div>
</div>
<a class="anchor" id="aaebbf9e049cd9c47c14495000f8eae42"></a><!-- doxytag: member="cds::ordered_list::details::michael_list_tagged::list_base::nc_begin" ref="aaebbf9e049cd9c47c14495000f8eae42" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR  = CDS_DEFAULT_ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base_1_1_non_concurrent_iterator.html">nonconcurrent_const_iterator</a> <a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html">cds::ordered_list::details::michael_list_tagged::list_base</a>&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::nc_begin </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns non-concurrent const forward start iterator. </p>
<p>For an empty list start iterator is equal to <em>end()</em> </p>

</div>
</div>
<a class="anchor" id="ab528b7909cf5f971e51f1fcbdb78c42e"></a><!-- doxytag: member="cds::ordered_list::details::michael_list_tagged::list_base::nc_end" ref="ab528b7909cf5f971e51f1fcbdb78c42e" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR  = CDS_DEFAULT_ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base_1_1_non_concurrent_iterator.html">nonconcurrent_iterator</a> <a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html">cds::ordered_list::details::michael_list_tagged::list_base</a>&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::nc_end </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns non-concurrent forward end iterator. </p>
<p>End iterator is simple NULL. You may use end iterator for comparison only </p>

</div>
</div>
<a class="anchor" id="abba0b85bb58aa6eb23d2672c2403e05a"></a><!-- doxytag: member="cds::ordered_list::details::michael_list_tagged::list_base::nc_end" ref="abba0b85bb58aa6eb23d2672c2403e05a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename VALUE , typename PAIR_TRAITS , typename TRAITS , class ALLOCATOR  = CDS_DEFAULT_ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base_1_1_non_concurrent_iterator.html">nonconcurrent_const_iterator</a> <a class="el" href="classcds_1_1ordered__list_1_1details_1_1michael__list__tagged_1_1list__base.html">cds::ordered_list::details::michael_list_tagged::list_base</a>&lt; KEY, VALUE, PAIR_TRAITS, TRAITS, ALLOCATOR &gt;::nc_end </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns non-concurrent const forward end iterator. </p>
<p>End iterator is simple NULL. You may use end iterator for comparison only </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/ordered_list/michael_list_tagged.h</li>
</ul>
</div>
		<hr/>
		<div align="right">
			<b>cds</b> <b>0.7.0</b> 
			Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2010
			<br/>
			<i>Autogenerated Sun Dec 5 2010 11:36:37 by Doxygen 1.7.2</i>
		</div>
	</BODY>
</HTML>

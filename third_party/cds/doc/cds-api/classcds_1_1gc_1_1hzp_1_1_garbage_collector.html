<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cds: cds::gc::hzp::GarbageCollector Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacecds.html">cds</a>      </li>
      <li><a class="el" href="namespacecds_1_1gc.html">gc</a>      </li>
      <li><a class="el" href="namespacecds_1_1gc_1_1hzp.html">hzp</a>      </li>
      <li><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html">GarbageCollector</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a>  </div>
  <div class="headertitle">
<h1>cds::gc::hzp::GarbageCollector Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="cds::gc::hzp::GarbageCollector" -->
<p>Hazard Pointer singleton.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;hzp.h&gt;</code></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1hplist__node.html">hplist_node</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal list of <a class="el" href="structcds_1_1gc_1_1hzp_1_1details_1_1_h_p_rec.html" title="Hazard pointer record of the thread.">cds::gc::hzp::details::HPRec</a>.  <a href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1hplist__node.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1_internal_state.html">InternalState</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal GC statistics.  <a href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1_internal_state.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1_statistics.html">Statistics</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal GC statistics.  <a href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1_statistics.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77b8ab2884857010aeaf192b0e83523b"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::CDS_DECLARE_EXCEPTION" ref="a77b8ab2884857010aeaf192b0e83523b" args="(HZPManagerEmpty,&quot;Global Hazard Pointer GarbageCollector is NULL&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a77b8ab2884857010aeaf192b0e83523b">CDS_DECLARE_EXCEPTION</a> (HZPManagerEmpty,&quot;Global Hazard Pointer <a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html">GarbageCollector</a> is NULL&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">No <a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html" title="Hazard Pointer singleton.">GarbageCollector</a> object is created. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10cf87cc78b7c3a5cea1d6ef208f4f93"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::CDS_DECLARE_EXCEPTION" ref="a10cf87cc78b7c3a5cea1d6ef208f4f93" args="(HZPTooMany,&quot;Not enough required Hazard Pointer count&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a10cf87cc78b7c3a5cea1d6ef208f4f93">CDS_DECLARE_EXCEPTION</a> (HZPTooMany,&quot;Not enough required Hazard Pointer count&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Not enough required Hazard Pointer count. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8533c264f525949b4fdd3acd07585483"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::getHazardPointerCount" ref="a8533c264f525949b4fdd3acd07585483" args="() const " -->
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a8533c264f525949b4fdd3acd07585483">getHazardPointerCount</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns max Hazard Pointer count defined in construction time. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac880856b93166953a26f8c764b668e3c"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::getMaxThreadCount" ref="ac880856b93166953a26f8c764b668e3c" args="() const " -->
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#ac880856b93166953a26f8c764b668e3c">getMaxThreadCount</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns max thread count defined in construction time. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa640f5cd380437f7ee649be15bcd4b23"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::getMaxRetiredPtrCount" ref="aa640f5cd380437f7ee649be15bcd4b23" args="() const " -->
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#aa640f5cd380437f7ee649be15bcd4b23">getMaxRetiredPtrCount</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns max size of retired objects array. It is defined in construction time. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad985a9c7cd12f3ab2f2fa4fcae254d7f"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::getInternalState" ref="ad985a9c7cd12f3ab2f2fa4fcae254d7f" args="(InternalState &amp;stat) const " -->
<a class="el" href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1_internal_state.html">InternalState</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#ad985a9c7cd12f3ab2f2fa4fcae254d7f">getInternalState</a> (<a class="el" href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1_internal_state.html">InternalState</a> &amp;stat) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get internal statistics. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae138f31cf537368b05a89622d73a0f81"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::isStatisticsEnabled" ref="ae138f31cf537368b05a89622d73a0f81" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#ae138f31cf537368b05a89622d73a0f81">isStatisticsEnabled</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if internal statistics enabled. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47b1c5520a9637e0420301020ddb3227"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::enableStatistics" ref="a47b1c5520a9637e0420301020ddb3227" args="(bool bEnable)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a47b1c5520a9637e0420301020ddb3227">enableStatistics</a> (bool bEnable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables/disables internal statistics. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08b7b53870d9aabefcd7cb28e7997aeb"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::AllocateHPRec" ref="a08b7b53870d9aabefcd7cb28e7997aeb" args="()" -->
<a class="el" href="structcds_1_1gc_1_1hzp_1_1details_1_1_h_p_rec.html">details::HPRec</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a08b7b53870d9aabefcd7cb28e7997aeb">AllocateHPRec</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates Hazard Pointer GC record. For internal use only. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae4a95cca765fdb510fb59b4466360e8"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::RetireHPRec" ref="aae4a95cca765fdb510fb59b4466360e8" args="(details::HPRec *pRec)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#aae4a95cca765fdb510fb59b4466360e8">RetireHPRec</a> (<a class="el" href="structcds_1_1gc_1_1hzp_1_1details_1_1_h_p_rec.html">details::HPRec</a> *pRec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Free HP record. For internal use only. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a01bb09f35b1062c4decffce171c5620d">Scan</a> (<a class="el" href="structcds_1_1gc_1_1hzp_1_1details_1_1_h_p_rec.html">details::HPRec</a> *pRec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The main garbage collecting function.  <a href="#a01bb09f35b1062c4decffce171c5620d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a9e7056afcbc33c6cea9b32799f2e02d0">HelpScan</a> (<a class="el" href="structcds_1_1gc_1_1hzp_1_1details_1_1_h_p_rec.html">details::HPRec</a> *pThis)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper scan routine.  <a href="#a9e7056afcbc33c6cea9b32799f2e02d0"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void CDS_STDCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a833468c0786c5a0661bdc1db6f16cf44">Construct</a> (size_t nHazardPtrCount=0, size_t nMaxThreadCount=0, size_t nMaxRetiredPtrCount=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates <a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html" title="Hazard Pointer singleton.">GarbageCollector</a> singleton.  <a href="#a833468c0786c5a0661bdc1db6f16cf44"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1aba5f6536d19ad75ec7b8281a8d24c9"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::Destruct" ref="a1aba5f6536d19ad75ec7b8281a8d24c9" args="()" -->
static void CDS_STDCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a1aba5f6536d19ad75ec7b8281a8d24c9">Destruct</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys global instance of <a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html" title="Hazard Pointer singleton.">GarbageCollector</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3c1621f0149d267180733f03e06c0bc"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::instance" ref="ab3c1621f0149d267180733f03e06c0bc" args="()" -->
static <a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html">GarbageCollector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#ab3c1621f0149d267180733f03e06c0bc">instance</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to <a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html" title="Hazard Pointer singleton.">GarbageCollector</a> instance. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade090e19517a5f78ec962a34293f67b2"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::isUsed" ref="ade090e19517a5f78ec962a34293f67b2" args="()" -->
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#ade090e19517a5f78ec962a34293f67b2">isUsed</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if global GC object is constructed and may be used. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#aca8ba27f700ea8628550f0087a6394eb">checkHPCount</a> (unsigned int nRequiredCount)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that required hazard pointer count <code>nRequiredCount</code> is less or equal then max hazard pointer count.  <a href="#aca8ba27f700ea8628550f0087a6394eb"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a350457d8d6a843fbc65f5365056cb30c">GarbageCollector</a> (size_t nHazardPtrCount=0, size_t nMaxThreadCount=0, size_t nMaxRetiredPtrCount=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor.  <a href="#a350457d8d6a843fbc65f5365056cb30c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac72af2c1c3de4dc0cbef2623624e63f9"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::~GarbageCollector" ref="ac72af2c1c3de4dc0cbef2623624e63f9" args="()" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#ac72af2c1c3de4dc0cbef2623624e63f9">~GarbageCollector</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dtor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae54bab023394c169aab592cf20e59077"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::NewHPRec" ref="ae54bab023394c169aab592cf20e59077" args="()" -->
<a class="el" href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1hplist__node.html">hplist_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#ae54bab023394c169aab592cf20e59077">NewHPRec</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate new HP record. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a473247d2dcbe379c9c7e7a92b0dfec8a">DeleteHPRec</a> (<a class="el" href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1hplist__node.html">hplist_node</a> *pNode)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Permanently deletes HPrecord <code>pNode</code>.  <a href="#a473247d2dcbe379c9c7e7a92b0dfec8a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#adbb722267c82e7bc69196d0346b3ad70">DeletePtr</a> (<a class="el" href="structcds_1_1gc_1_1details_1_1retired__ptr.html">details::retired_ptr</a> &amp;p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Permanently deletes retired pointer <code>p</code>.  <a href="#adbb722267c82e7bc69196d0346b3ad70"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0e5d9ba7f343e57d063a240fd0f8638"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::m_pListHead" ref="af0e5d9ba7f343e57d063a240fd0f8638" args="" -->
<a class="el" href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1hplist__node.html">hplist_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#af0e5d9ba7f343e57d063a240fd0f8638">m_pListHead</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Head of GC list. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a820c23aadfcafce89a3f8c9f0c95ab65"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::m_Stat" ref="a820c23aadfcafce89a3f8c9f0c95ab65" args="" -->
<a class="el" href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1_statistics.html">Statistics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a820c23aadfcafce89a3f8c9f0c95ab65">m_Stat</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal statistics. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3001475b9ab9ff7789e33b241a8ea2b9"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::m_bStatEnabled" ref="a3001475b9ab9ff7789e33b241a8ea2b9" args="" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a3001475b9ab9ff7789e33b241a8ea2b9">m_bStatEnabled</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">true - statistics enabled <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08750cabd8d3dabdb3d82a464c924f1a"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::m_nHazardPointerCount" ref="a08750cabd8d3dabdb3d82a464c924f1a" args="" -->
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a08750cabd8d3dabdb3d82a464c924f1a">m_nHazardPointerCount</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">max count of thread's hazard pointer <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a824fff7e9b1d7cfcfaa60b7d1d1853d1"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::m_nMaxThreadCount" ref="a824fff7e9b1d7cfcfaa60b7d1d1853d1" args="" -->
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a824fff7e9b1d7cfcfaa60b7d1d1853d1">m_nMaxThreadCount</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">max count of thread <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2199b0cb3b53d071359731bcfa02904"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::m_nMaxRetiredPtrCount" ref="ad2199b0cb3b53d071359731bcfa02904" args="" -->
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#ad2199b0cb3b53d071359731bcfa02904">m_nMaxRetiredPtrCount</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">max count of retired ptr per thread <br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fb10d9cadadffd5feb0c4eee087251c"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::m_pHZPManager" ref="a8fb10d9cadadffd5feb0c4eee087251c" args="" -->
static <a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html">GarbageCollector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a8fb10d9cadadffd5feb0c4eee087251c">m_pHZPManager</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">GC instance pointer. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Hazard Pointer singleton. </p>
<p>Safe memory reclamation schema by Michael "Hazard Pointers"</p>
<dl class="user"><dt><b>Sources:</b></dt><dd><ul>
<li>[2002] Maged M.Michael "Safe memory reclamation for dynamic lock-freeobjects using atomic reads and writes" </li>
<li>[2003] Maged M.Michael "Hazard Pointers: Safe memory reclamation for lock-free objects" </li>
<li>[2004] Andrei Alexandrescy, Maged Michael "Lock-free Data Structures with Hazard Pointers" </li>
</ul>
</dd></dl>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a350457d8d6a843fbc65f5365056cb30c"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::GarbageCollector" ref="a350457d8d6a843fbc65f5365056cb30c" args="(size_t nHazardPtrCount=0, size_t nMaxThreadCount=0, size_t nMaxRetiredPtrCount=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cds::gc::hzp::GarbageCollector::GarbageCollector </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"> <em>nHazardPtrCount</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"> <em>nMaxThreadCount</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"> <em>nMaxRetiredPtrCount</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ctor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nHazardPtrCount</td><td>Hazard pointer count per thread </td></tr>
    <tr><td class="paramname">nMaxThreadCount</td><td>Max count of thread </td></tr>
    <tr><td class="paramname">nMaxRetiredPtrCount</td><td>Capacity of the array of retired objects </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aca8ba27f700ea8628550f0087a6394eb"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::checkHPCount" ref="aca8ba27f700ea8628550f0087a6394eb" args="(unsigned int nRequiredCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void cds::gc::hzp::GarbageCollector::checkHPCount </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"> <em>nRequiredCount</em>&#160;)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks that required hazard pointer count <code>nRequiredCount</code> is less or equal then max hazard pointer count. </p>
<p>If <code>nRequiredCount</code> &gt; <a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html#a8533c264f525949b4fdd3acd07585483" title="Returns max Hazard Pointer count defined in construction time.">getHazardPointerCount()</a> then the exception HZPTooMany is thrown </p>

</div>
</div>
<a class="anchor" id="a833468c0786c5a0661bdc1db6f16cf44"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::Construct" ref="a833468c0786c5a0661bdc1db6f16cf44" args="(size_t nHazardPtrCount=0, size_t nMaxThreadCount=0, size_t nMaxRetiredPtrCount=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void CDS_STDCALL cds::gc::hzp::GarbageCollector::Construct </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"> <em>nHazardPtrCount</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"> <em>nMaxThreadCount</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"> <em>nMaxRetiredPtrCount</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates <a class="el" href="classcds_1_1gc_1_1hzp_1_1_garbage_collector.html" title="Hazard Pointer singleton.">GarbageCollector</a> singleton. </p>
<p>GC is the singleton. If GC instance is not exist then the function creates the instance. Otherwise it does nothing.</p>
<p>The Michael's HP reclamation schema depends of three parameters:</p>
<p><code>nHazardPtrCount</code> - HP pointer count per thread. Usually it is small number (2-4) depending from the data structure algorithms. By default, if <code>nHazardPtrCount</code> = 0, the function uses maximum of HP count for CDS library.</p>
<p><code>nMaxThreadCount</code> - max count of thread with using HP GC in your application. Default is 100.</p>
<p><code>nMaxRetiredPtrCount</code> - capacity of array of retired pointers for each thread. Must be greater than <code>nHazardPtrCount</code> * <code>nMaxThreadCount</code>. Default is 2 * <code>nHazardPtrCount</code> * <code>nMaxThreadCount</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nHazardPtrCount</td><td>Hazard pointer count per thread </td></tr>
    <tr><td class="paramname">nMaxThreadCount</td><td>Max count of thread in your application </td></tr>
    <tr><td class="paramname">nMaxRetiredPtrCount</td><td>Capacity of the array of retired objects for the thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a473247d2dcbe379c9c7e7a92b0dfec8a"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::DeleteHPRec" ref="a473247d2dcbe379c9c7e7a92b0dfec8a" args="(hplist_node *pNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cds::gc::hzp::GarbageCollector::DeleteHPRec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcds_1_1gc_1_1hzp_1_1_garbage_collector_1_1hplist__node.html">hplist_node</a> *&#160;</td>
          <td class="paramname"> <em>pNode</em>&#160;)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Permanently deletes HPrecord <code>pNode</code>. </p>
<p>Caveat: for performance reason this function is defined as inline and cannot be called directly </p>

</div>
</div>
<a class="anchor" id="adbb722267c82e7bc69196d0346b3ad70"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::DeletePtr" ref="adbb722267c82e7bc69196d0346b3ad70" args="(details::retired_ptr &amp;p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cds::gc::hzp::GarbageCollector::DeletePtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcds_1_1gc_1_1details_1_1retired__ptr.html">details::retired_ptr</a> &amp;&#160;</td>
          <td class="paramname"> <em>p</em>&#160;)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Permanently deletes retired pointer <code>p</code>. </p>
<p>Caveat: for performance reason this function is defined as inline and cannot be called directly </p>

</div>
</div>
<a class="anchor" id="a9e7056afcbc33c6cea9b32799f2e02d0"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::HelpScan" ref="a9e7056afcbc33c6cea9b32799f2e02d0" args="(details::HPRec *pThis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cds::gc::hzp::GarbageCollector::HelpScan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcds_1_1gc_1_1hzp_1_1details_1_1_h_p_rec.html">details::HPRec</a> *&#160;</td>
          <td class="paramname"> <em>pThis</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper scan routine. </p>
<p>The function guarantees that every node that is eligible for reuse is eventually freed, barring thread failures. To do so, after executing Scan, a thread executes a HelpScan, where it checks every HP record. If an HP record is inactive, the thread moves all "lost" reclaimed pointers to thread's list of reclaimed pointers.</p>
<p>The function is called internally by Scan. </p>

</div>
</div>
<a class="anchor" id="a01bb09f35b1062c4decffce171c5620d"></a><!-- doxytag: member="cds::gc::hzp::GarbageCollector::Scan" ref="a01bb09f35b1062c4decffce171c5620d" args="(details::HPRec *pRec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cds::gc::hzp::GarbageCollector::Scan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcds_1_1gc_1_1hzp_1_1details_1_1_h_p_rec.html">details::HPRec</a> *&#160;</td>
          <td class="paramname"> <em>pRec</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The main garbage collecting function. </p>
<p>A scan includes four stages. The first stage involves scanning the array HP for non-null values. Whenever a non-null value is encountered, it is inserted in a local list of currently protected pointer. Only stage 1 accesses shared variables. The following stages operate only on private variables.</p>
<p>The second stage of a scan involves sorting local list of protected pointers to allow binary search in the third stage.</p>
<p>The third stage of a scan involves checking each reclaimed node against the pointers in local list of protected pointers. If the binary search yields no match, the node is freed. Otherwise, it cannot be deleted now and must kept in thread's list of reclaimed pointers.</p>
<p>The forth stage prepares new thread's private list of reclaimed pointers that could not be freed during the current scan, where they remain until the next scan.</p>
<p>This function is called internally by <a class="el" href="classcds_1_1gc_1_1hzp_1_1_thread_g_c.html" title="Thread&#39;s hazard pointer manager.">ThreadGC</a> object when upper bound of thread's list of reclaimed pointers is reached. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/gc/hzp/hzp.h</li>
</ul>
</div>
		<hr/>
		<div align="right">
			<b>cds</b> <b>0.7.0</b> 
			Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2010
			<br/>
			<i>Autogenerated Sun Dec 5 2010 11:36:31 by Doxygen 1.7.2</i>
		</div>
	</BODY>
</HTML>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cds: cds::gc::ptb Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacecds.html">cds</a>      </li>
      <li><a class="el" href="namespacecds_1_1gc.html">gc</a>      </li>
      <li><a class="el" href="namespacecds_1_1gc_1_1ptb.html">ptb</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<h1>cds::gc::ptb Namespace Reference</h1>  </div>
</div>
<div class="contents">

<p>Pass The Buck reclamation schema.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecds_1_1gc_1_1ptb_1_1details.html">details</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Details of Pass the Buck algorithm. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1ptb_1_1_container.html">Container</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The base for all containers based on the Pass-the-Buck GC.  <a href="classcds_1_1gc_1_1ptb_1_1_container.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1ptb_1_1_guard.html">Guard</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcds_1_1gc_1_1ptb_1_1_guard.html" title="Guard.">Guard</a>.  <a href="classcds_1_1gc_1_1ptb_1_1_guard.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1ptb_1_1_guard_array.html">GuardArray</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of guards.  <a href="classcds_1_1gc_1_1ptb_1_1_guard_array.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1ptb_1_1_garbage_collector.html">GarbageCollector</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory manager (Garbage collector)  <a href="classcds_1_1gc_1_1ptb_1_1_garbage_collector.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1ptb_1_1_thread_g_c.html">ThreadGC</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread GC.  <a href="classcds_1_1gc_1_1ptb_1_1_thread_g_c.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd44387438015c3ff5b56d678c04d16f"></a><!-- doxytag: member="cds::gc::ptb::retired_ptr" ref="afd44387438015c3ff5b56d678c04d16f" args="" -->
typedef <br class="typebreak"/>
<a class="el" href="structcds_1_1gc_1_1details_1_1retired__ptr.html">cds::gc::details::retired_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecds_1_1gc_1_1ptb.html#afd44387438015c3ff5b56d678c04d16f">retired_ptr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retired pointer type. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Pass The Buck reclamation schema. </p>
<dl class="user"><dt><b>Sources:</b></dt><dd><ul>
<li>[2002] M. Herlihy, V. Luchangco, and M. Moir. The repeat offender problem: A mechanism for supporting dynamic-sized lockfree data structures. Technical Report TR-2002-112, Sun Microsystems Laboratories, 2002 </li>
<li>[2002] M. Herlihy, V. Luchangco, P. Martin, and M. Moir. Dynamic-sized Lockfree Data Structures. Technical Report TR-2002-110, Sun Microsystems Laboratories, 2002 </li>
<li>[2005] M. Herlihy, V. Luchangco, P. Martin, and M. Moir. Nonblocking Memory Management Support for Dynamic_Sized Data Structures. ACM Transactions on Computer Systems, Vol.23, No.2, May 2005</li>
</ul>
</dd></dl>
<dl class="user"><dt><b>Usage</b></dt><dd>The main part of Pass The Buck (PTB) memory manager is <a class="el" href="classcds_1_1gc_1_1ptb_1_1_garbage_collector.html" title="Memory manager (Garbage collector)">cds::gc::ptb::GarbageCollector</a> class. Only one object of this class can be created.</dd></dl>
<p>Before using of <a class="el" href="structcds_1_1gc_1_1ptb__gc.html" title="Tag for &quot;Pass the Buck&quot; reclamation schema.">cds::gc::ptb_gc</a> -based data structure from CDS library you need to initialize PTB memory manager in your main() function by calling <a class="el" href="classcds_1_1gc_1_1ptb_1_1_garbage_collector.html#ab84b0e25888dca13a32726fd43f3a98b" title="Initializes PTB memory manager singleton.">cds::gc::ptb::GarbageCollector::Construct</a>. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">            #include &lt;cds/gc/ptb/ptb.h&gt;</span>

            <span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {

                <span class="comment">// Init PTB GC</span>
                <a class="code" href="classcds_1_1gc_1_1ptb_1_1_garbage_collector.html#ab84b0e25888dca13a32726fd43f3a98b" title="Initializes PTB memory manager singleton.">cds::gc::ptb::GarbageCollector::Construct</a>()    ;

                <span class="comment">// Do some work</span>
                ...

                <span class="comment">// Destruct PTB GC</span>
                <a class="code" href="classcds_1_1gc_1_1ptb_1_1_garbage_collector.html#aca8282ef97000c6892a6a409f29b8b95" title="Destroys PTB memory manager.">cds::gc::ptb::GarbageCollector::Destruct</a>()    ;

                <span class="keywordflow">return</span> 0    ;
            }
</pre></div><p>The PTB GC provides only core functionality that is not intended for direct use in your code. Instead, each thread works with <a class="el" href="classcds_1_1gc_1_1ptb_1_1_thread_g_c.html" title="Thread GC.">cds::gc::ptb::ThreadGC</a> object that is middle layer between PTB GC kernel and your thread. Before applying a PTB-based container, the <a class="el" href="classcds_1_1gc_1_1ptb_1_1_thread_g_c.html" title="Thread GC.">ThreadGC</a> object must be created and initialized properly by calling <a class="el" href="namespacecds_1_1threading.html" title="Threading support.">cds::threading</a> Manager::attachThread() function in beginning of your thread. Before terminating the thread must call <a class="el" href="namespacecds_1_1threading.html" title="Threading support.">cds::threading</a> Manager::detachThread() function. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">            #include &lt;cds/threading/model.h&gt;</span>

            <span class="comment">// Thread function</span>
            <span class="keywordtype">int</span> myThreadEntryPoint()
            {
                <span class="comment">// Attach current thread to GC used</span>
                <span class="comment">// Note, there is only one attachThread call.</span>
                <span class="comment">// The CDS library will properly initialize each GC constructed by you in single attachThread call</span>
                cds::threading::Manager::attachThread()

                <span class="comment">// Do thread&#39;s work</span>
                ...

                <span class="comment">// Detach current thread from GC used</span>
                <span class="comment">// Note, there is only one detachThread call</span>
                cds::threading::Manager::detachThread()

                return 0    ;
            }
</pre></div><dl class="user"><dt><b>Implementation issues</b></dt><dd>At present, the access to <code>liberate</code> function is serialized inside the PTB GC. There is no waiting: if a thread detects that <code>liberate</code> is busy by some other ones then the thread skips the call of <code>liberate</code> and continues to work. This solution allows to significantly reduce the complexity of <code>liberate</code> function.</dd></dl>
<p>Unlike <code>liberate</code> function described in the paper [2005], current implementation may push the hand-off retired pointer trapped by the guard back to the buffer of retired pointer. Additional analysis is required to solve this problem.</p>
<p>The global list of free guards (<a class="el" href="classcds_1_1gc_1_1ptb_1_1details_1_1guard__allocator.html" title="Guard allocator.">cds::gc::ptb::details::guard_allocator</a>) is protected by spin-lock (i.e. serialized). It seems that solution should not introduce significant performance bottleneck, because each thread has own set of guards allocated from global list of free guards and access to global list is occurred only when all thread's guard is busy. In this case the thread allocates next block of guards from global list of free guards. Guards allocated for the thread is pushed back to the global list only when the thread terminates. </p>
</div>
		<hr/>
		<div align="right">
			<b>cds</b> <b>0.7.0</b> 
			Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2010
			<br/>
			<i>Autogenerated Sun Dec 5 2010 11:36:31 by Doxygen 1.7.2</i>
		</div>
	</BODY>
</HTML>
